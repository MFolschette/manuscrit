\section{Frappes de Processus avec classes de priorités}
\seclabel{php}

\todo{Mise en perspective}

Pour tout entier naturel $k$ non nul,
les \emph{Frappes de Processus avec $k$ classes de priorités}
%(aussi appelées «~Frappes de Processus~» dans la suite, lorsque ce n'est pas ambigu),
sont des Frappes de Processus dont l'ensemble des actions est partitionné
en $k$ ensembles, chacun étant associé à une classe de priorité distincte.
Cela signifie qu'une action est jouable dans un état si et seulement si,
en plus de la condition de la présence du frappeur et de la cible,
il n'existe aucune autre action appartenant à une classe de priorité plus grande
qui soit aussi jouable dans cet état.
Il est à noter que les classes de priorités sont étiquetées de façon décroissante par les entiers de
l'ensemble $\segm{1}{k}$ en fonction de l'importance de la priorité ;
autrement dit, la classe de priorités 1 contient les actions les plus prioritaires,
ne pouvant jamais être préemptées,
tandis que la jouabilité d'une action de la classe de priorité $k$ ne peut pas empêcher le jeu
d'une autre action.

Cette modélisation permet notamment de distinguer les actions en fonction 
de différents critères comme
leur vitesse d'exécution (les actions les plus rapides étant jouées en priorité),
ou tout autre paramètre permettant de déterminer l'existence de la préemption d'une action
en fonction de la possibilité d'en jouer une autre.
L'application la plus poussée de cette utilisation consisterait à
classer les actions d'un modèle en fonction d'un tel critère,
et à attribuer à chaque classe de priorité une action unique en fonction de ce classement,
afin de créer un ordre total entre toutes les actions défini par leurs priorités.
%afin de rendre compte de la priorité de chaque action en fonction de chaque autre.

De même, ces classes de priorités permettent de prendre en compte des comportements non biologiques
inhérents à la modélisation.
Il est par exemple possible de donner une priorité différente aux
actions qui n'ont pas de sens biologique propre
--- mais dont ce sens émerge uniquement dans leur relation avec d'autres actions.
L'application la plus immédiate de ce cas est celle des actions de mise à jour
des sortes coopérative \todo{ref PH canonique},
où une classe de priorités supérieure offre l'avantage de supprimer les effets d'entrelacement,
et ainsi de simuler le comportement d'une véritable porte logique sans décalage temporel \todo{ref}.

Cette représentation basée sur des classes de priorités permet de modéliser un système
dont les actions peuvent être distinguées en plusieurs classes en fonction de leur importance,
de leur vitesse d'exécution, ou encore d'autres facteurs leur donnant prévalence sur d'autres.
Chaque action peut donc en préempter un ensemble d'autres en fonction de sa classe de priorités.
Cela permet une représentation compacte, des rapports de priorités entre actions
ou, autrement dit, de leur ordonnancement,
qui présente néanmoins quelques lacunes.
Les phénomènes d'accumulation, notamment, n'y sont pas représentés ;
un cycle d'actions prioritaires ne peut jamais être interrompu par une action moins prioritaire,
menant à un cycle infini et pouvant contredire la réalité biologique.
De plus, les classes de priorités définies pour un modèle sont invariables;
certains modèles pourraient cependant nécessiter l'évolution de certaines classes de priorités
en fonction de la présence ou de l'absence d'un composant dans un état donné.
Enfin, elles peuvent ne pas permettre la précision nécessaire à une représentation fidèle de
certains modèles, notamment lorsqu'il est nécessaire de définir des préemptions ponctuelles
comme le permettent les Frappes de Processus avec arcs neutralisants
présentées à la \secref{phan}.

\pref{fig:metazoan-php}



\subsection{Définition}
\seclabel{php-def}

\begin{definition}[Frappes de Processus avec $k$ classes de priorités]
\deflabel{php}
  Si $k \in \sN^*$, les \emph{Frappes de Processus avec $k$ classes de priorités} sont définies
  par un triplet $\PH = (\PHs; \PHl; \PHh^{\langle k \rangle})$,
  où $\PHh^{\langle k \rangle} = (\PHh^{(1)}; \dots; \PHh^{(k)})$ est un $k$-uplet, et :
  \begin{itemize}
    \item $\PHs \DEF \{a, b, \dots\}$ est l'ensemble fini et dénombrable des \emph{sortes} ;
    \item $\PHl \DEF \bigtimes{a \in \PHs} \PHl_a$ est l'ensemble fini des \emph{états},
      où $\PHl_a = \{a_0, \ldots, a_{l_a}\}$ est l'ensemble fini et dénombrable
      des \emph{processus} de la sorte $a \in \PHs$ et $l_a \in \sN^*$.
      Chaque processus appartient à une unique sorte :
      $\forall (a_i; b_j) \in \PHl_a \times \PHl_b, a \neq b \Rightarrow a_i \neq b_j$ ;
    \item pour tout $n \in \llbracket 1; k \rrbracket$,
      $\PHh^{(n)} \DEF \{\PHfrappe{a_i}{b_j}{b_l} \mid (a; b) \in \PHs^2 \wedge
      (a_i; b_j; b_l) \in \PHl_a \times \PHl_b \times \PHl_b \wedge
      b_j \neq b_l \wedge a = b \Rightarrow a_i = b_j \}$ est l'ensemble fini
      des \emph{actions de priorité $n$}.
  \end{itemize}
  On note $\PHh \DEF \bigcup_{n \in \segm{1}{k}} \PHh^{(n)}$ l'ensemble de toutes les actions
  et, pour tout $n \in \sN^*$ et $h \in \PHh^{(n)}$, $\prio(h) \DEF n$.
\end{definition}
%
\noindent
On réutilise de surcroît les notations définies à la \secref{ph} concernant les états et
l'extraction de la sorte d'un processus.

%La sorte d'un processus $a_i$ est donnée par $\PHsort(a_i) = a$.
%Étant donné un état $s \in \PHl$, le processus de la sorte $a \in \PHs$ présent dans $s$ est donné
%par $\PHget{s}{a}$, \cad la coordonnée correspondant à $a$ dans l'état $s$.
%Si $a_i \in \PHl_a$, nous définissons la notation : $a_i \in s \EQDEF \PHget{s}{a} = a_i$.

À l'instar de la \secref{ph}, il faut définir un opérateur de jouabilité
pour déterminer la dynamique des Frappes de Processus avec $k$ classes de priorités.
Cependant, à l'inverse de celui des Frappes de Processus standard (\defref{fopph})
il faut ici prendre en compte la possible présence d'actions jouables appartenant à des
classes de priorités supérieures.
Pour cela, il est suffisant de vérifier que le frappeur et la cible de toute action
de priorité plus importante ne sont pas simultanément présents.
En effet, prenons deux actions $g, h \in \PHh$ avec : $\prio(g) < \prio(h)$, et
un état $s \in \PHl$ tel que $\frappeur{g} \in s \wedge \cible{g} \in s$ ;
Deux cas de figures sont alors possibles :
\begin{itemize}
  \item l'action $g$ est jouable dans $s$ --- autrement dit, aucune autre action de priorité plus
    importante ne la préempte -- et elle préempte $h$ en conséquence,
  \item l'action $g$ n'est pas jouable dans $s$, ce qui signifie qu'elle est préemptée par une
    action de priorité plus importante, qui préempte alors aussi l'action $h$.
\end{itemize}
Dans les deux cas, $h$ n'est pas jouable, ce qui montre qu'il est suffisant de n'observer
que la présence simultanée du frappeur et de la cible de chaque action de priorité supérieure
pour déterminer la jouabilité de $h$.
Nous obtenons alors l'opérateur de jouabilité donné à la \defref{fopphp}.

\begin{definition}[Opérateur de jouabilité ($\Fopsymbol_\Fopphpsubsymbol : \PHh \rightarrow \F$)]
\deflabel{fopphp}
  L'opérateur de jouabilité des Frappes de Processus avec $k$ classes de priorités est défini par :
  \[\forall h \in \PHh, \Fopphp{h} \equiv \hitter{h} \wedge \target{h} \wedge
    \left( \bigwedge_{\substack{g \in \PHh^{(n)}\\n < \prio(h)}}
    \neg \left( \hitter{g} \wedge \target{g} \right) \right)\]
\end{definition}



\begin{example}
\exlabel{metazoan-php}
  Nous illustrons les possibilités offertes par l'introduction des classes de priorités
  par la \figref{metazoan-php} qui représente un modèle de Frappes de Processus
  avec 3 classes de priorités $\PH = (\PHs, \PHl, \PHh^{\angles{3}})$.
  Celui-ci reprend la structure du modèle de Frappes de Processus standards
  de la \figref{metazoan-ph},
  en y ajoutant trois classes de priorités permettant de distinguer trois types d'actions :
  \begin{itemize}
    \item les actions de $\PHh^{(1)}$ permettent d'assigner une priorité maximale
      aux actions mettant à jour la sorte coopérative $fc$,
      et peuvent être considérées comme «~instantanées~» du point de vue du reste du modèle ;
    \item les actions de $\PHh^{(2)}$ assurent que la sorte $a$ est mise à jour immédiatement
      en fonction de l'évolution de $f$ et $c$,
      et peuvent être vues comme «~urgentes~» par rapport aux actions de $\PHh^{(3)}$ ;
    \item enfin, les actions restantes sont par conséquent considérées comme «~lentes~»
      ou «~peu urgentes~» en regard du reste du modèle ;
      il s'agit des actions de $\PHh^{(3)}$, qui représentent des processus biologiques
      plus lents.
  \end{itemize}
  Comme expliqué par la suite au \chapref{phcanonique},
  assigner la priorité maximale aux actions permettant la mise à jour des
  sortes coopératives permet d'éviter les comportements indésirables
  décrits à la page \expageref{metazoan-ph-nocoop}.
  De même, accorder aux actions de $\PHh^{(2)}$ le statut d'«~urgentes~»
  permet de s'assurer qu'elles seront jouée avant les actions de $\PHh^{(3)}$.
  Dans ce modèle, cela se traduit par le fait que l'activation ou la désactivation de $a$
  est forcée lorsque $c$ et $f$ évoluent,
  ce qui restreint la dynamique aux seuls comportements désirés.
  En effet, la seule dynamique possible, en partant de l'état initial
  $\etat{a_0, c_0, f_1, fc_{10}}$,
  consiste en un comportement stationnaire oscillant,
  où $c$ et $a$ sont alternativement activés et désactivés,
  interrompu par la désactivation de $f$ qui entraîne irrémédiablement celle de $c$,
  sans possibilité de le ré-activer par la suite,
  et provoque cette fois un comportement stationnaire constant
  (qui se traduit en Frappes de Processus par un point fixe
  où $a$ reste indéfiniment à sa dernière valeur (actif ou non).
  Le comportement stationnaire est donné par le scénario suivant,
  jouable dans l'état initial $\etat{a_0, c_0, f_1, fc_{10}}$ :
  \begin{align*}
    \PHfrappe{fc_{10}}{a_0}{a_1} &\cons
    \PHfrappe{f_1}{c_0}{c_1} \cons
    \PHfrappe{c_1}{fc_{10}}{fc_{11}} \cons \\
    &\PHfrappe{c_1}{a_1}{a_0} \cons
    \PHfrappe{c_1}{c_1}{c_0} \cons
    \PHfrappe{c_0}{fc_{11}}{fc_{10}}
  \end{align*}
  L'interruption de ce comportement stationnaire se fait grâce à l'auto-action
  $\PHfrappe{f_1}{f_1}{f_0}$, qui est de priorité 3, et donc jouable uniquement
  dans les deux états suivants :
  $\etat{a_1, c_0, f_1, fc_{10}}$ et $\etat{a_0, c_1, f_1, fc_{11}}$.
  Depuis le premier état, la désactivation est opérée par le scénario suivant :
  \[
    \PHfrappe{f_1}{f_1}{f_0} \cons
    \PHfrappe{f_0}{fc_{10}}{fc_{00}}
    \enspace,
  \]
  qui termine dans l'état $\etat{a_1, c_0, f_0, fc_{00}}$ et conserve donc le processus $a_1$,
  tandis que depuis le deuxième état, la désactivation est opérée par le scénario :
  \[
    \PHfrappe{f_1}{f_1}{f_0} \cons
    \PHfrappe{f_0}{fc_{11}}{fc_{01}} \cons
    \PHfrappe{f_0}{c_1}{c_0} \cons
    \PHfrappe{c_0}{fc_{01}}{fc_{00}}
    \enspace,
  \]
  qui termine en $\etat{a_0, c_0, f_0, fc_{00}}$ et conserve cette fois le processus $a_0$.
  
  Pour finir, il est intéressant de noter que l'introduction de classes de priorités ne permet
  cependant pas la représentation de phénomènes de retard, comme expliqué plus haut.
  En effet, il n'est pas possible par exemple de n'autoriser la désactivation de $f$
  qu'après un nombre donné d'oscillations de $a$ ou de $c$.
  Pour représenter cela, un modélisateur pourrait être tenté d'introduire une classe de
  priorité $4$ afin d'y intégrer l'action $\PHfrappe{f_1}{f_1}{f_0}$,
  en effectuant un parallèle avec les paramètres stochastiques proposés \toref
  qui permettent de ne tirer cette action qu'après un certain nombre d'oscillations.
  Cependant, un tel choix de conception aurait uniquement pour effet de rendre ladite action
  injouable, car sans cesse préemptée par des actions de priorité supérieure.
  En effet, les phénomènes d'accumulation ne sont pas pris en compte,
  ce qui signifie qu'il n'y a pas d'«~accumulation~» du temps de sensibilisation en arrière-plan
  dans le formalisme des Frappes ce Processus avec classes de priorités.
  \todo{À mettre plus tard ? Dans la partie Paramètres stochastiques ?}
  
  \begin{figure}[ht]
  \begin{center}
  \begin{tikzpicture}
    \TSort{(0,4)}{c}{2}{l}
    \TSort{(1,0)}{f}{2}{l}
    \TSort{(7,4)}{a}{2}{r}
    
    \TSetTick{fc}{0}{00}
    \TSetTick{fc}{1}{01}
    \TSetTick{fc}{2}{10}
    \TSetTick{fc}{3}{11}
    \TSort{(4,1)}{fc}{4}{r}
    
    \TAction{fc_2}{a_0.west}{a_1.south west}{}{left}
    \TAction{c_1}{a_1.west}{a_0.north west}{}{right}
    \TAction{f_1}{c_0.west}{c_1.south west}{bend left=30, in=90}{left}
    \TAction{c_1}{c_1.west}{c_0.north west}{selfhit}{right}
    \TAction{f_1.north east}{f_1.south east}{f_0.north east}%
      {selfhit, min distance=30, bend left, out=150, in=90}{left}
    \TAction{f_0.east}{c_1.south east}{c_0.north east}{bend right=60, in=-140}{left}
    
    \path (1.8, 0.5) edge[coopupdate] (3.2, 2);
    \path (0.8, 4.5) edge[coopupdate] (3.2, 3);
    
    \node[labelprio1] at (2.55,3.85) {$1$}; % c => fc
    \node[labelprio1] at (2.75,1) {$1$};    % f => fc
    \node[labelprio2] at (5.5,3.85) {$2$};  % fc_10 -> a_0 / 1
    \node[labelprio2] at (3.5,5.3) {$2$};   % c_1 -> a_1 / 0
    \node[labelprio3] at (0,2.5) {$3$};     % f_1 -> c_0 / 1
    \node[labelprio3] at (0.8,5.8) {$3$};   % c_1 -> c_1 / 0
    \node[labelprio3] at (2.15,2.5) {$3$};  % f_0 -> c_1 / 0
    \node[labelprio3] at (1.5,1.8) {$3$};   % f_1 -> f_1 / 0
    
    \TState{f_1, a_0, c_0, fc_2}
  \end{tikzpicture}
  \caption{\figlabel{metazoan-php}%
    Exemple de Frappes de Processus avec 3 classes de priorités.
    Ce modèle est issu de celui de la \figref{metazoan-ph}
    auquel ont été rajoutées des classes de priorités.
    Les étiquettes numérotées (de 1 à 3) placées contre les flèches représentant les actions
    symbolisent leur appartenance à une classe de priorités donnée ;
    ainsi, on a notamment :
    $\PHh^{(2)} = \{ \PHfrappe{fc_{10}}{a_0}{a_1} ; \PHfrappe{c_1}{a_1}{a_0} \}$.
  }
  \end{center}
  \end{figure}
\end{example}



\subsection{Équivalences entres Frappes de Processus avec $k$ classes de priorités}

\todo{À garder ?}

Nous montrons à la \secref{aplatissement} que les Frappes de Processus avec $k$ classes
de priorités sont aussi expressives que les Frappes de Processus avec $n$ classes de
priorités, pour tout $k, n \in \sNN$.
Nous donnons pour cela un résultat encore plus fort : tout modèle de Frappes de Processus avec $k$
classes de priorités peut être traduit en Frappes de Processus canoniques,
comme défini à la \secref{phcanonique-def},
c'est-à-dire en Frappes de Processus avec 2 classes de priorités et une restriction
dans l'utilisation des actions de forte priorité.
À l'inverse des Frappes de Processus avec 2 classes de priorités sont \textit{a fortiori}
des Frappes de Processus avec $k$ classes de priorités, pour tout $k \in \sNN$.

\todo{En faire un théorème ?}



\subsection{Réutilisation des outils existants}
\seclabel{php-outils}

\todo{Revoir le titre de cette section}

\todo{Faudrait-il fusionner cette section avec ses semblables des \secref{phan} et \secref{phm} ?}

\subsubsection{Points fixes}
\seclabel{php-outils-pf}

\stodo{Ref points fixes chapitre 2}

Si l'ensemble de toutes les actions reste le même,
ajouter (ou retirer) des classes de priorités à des Frappes de Processus ne change pas
l'ensemble de ses points fixes.
En effet, le \thmref{php-pf} stipule que
l'ensemble des points fixes des Frappes de Processus avec $k$
classes de priorités $\PH$ est identique à l'ensemble des points fixes de
sa \emph{fusion} $\PHmerge(\PH)$,
c'est-à-dire le même modèle dont les classes de priorités ont été fusionnées,
tel que formalisé à la \defref{fusion}.
Cela se démontre simplement en constatant qu'il existe une action jouable dans un état donné du
modèle $\PH$ si et seulement si il en existe une dans le même état du modèle fusionné.
En effet, si une action est jouable dans un état donné de $\PHmerge(\PH)$,
alors soit elle est jouable car non préemptée dans le même état de $\PH$,
soit elle ne l'est pas car elle est préemptée par une autre action qui, elle, est jouable.
L'autre sens de la démonstration est immédiat car l'ajout de priorités restreint la dynamique
et n'ajoute aucun comportement supplémentaire possible.
Ce résultat permet d'appliquer aux Frappes de Processus avec $k$ classes de priorités
la méthode de recherche de points fixes développée pour les Frappes de Processus standards.
Cette méthode repose sur la recherche de $n$\nbd cliques,
ce qui est un problème classique jouissant aujourd'hui de méthodes de résolutions performantes.
\todo{Parler de la résolution par SAT ou ASP ?}
Enfin, ce résultat permet aussi de conclure quant aux ensembles de points fixes de deux Frappes
de Processus avec un nombre de classes de priorités différent, à condition que
leurs modèles fusionnés soient identiques.

\begin{definition}[Fusion ($\PHmerge$)]
\deflabel{fusion}
  Soient $\PH = (\PHs, \PHl, \PHh^{\angles{k}})$ des Frappes de Processus avec $k$
  classes de priorités, où $k \in \sN^*$.
  On note $\PHmerge(\PH) = (\PHs, \PHl, \PHh)$
  les Frappes de Processus standards appelées \emph{fusion} de $\PH$,
  dont l'ensemble des actions est l'union de toutes les classes de priorités de $\PH$.
\end{definition}

\begin{theorem}[Points fixes des Frappes de Processus avec classes de priorités]
\thmlabel{php-pf}
  Soient $\PH = (\PHs, \PHl, \PHh^{\angles{k}})$, où $k \in \sN^*$,
  des Frappes de Processus avec $k$ classes de priorités,
%  et $\PH' = (\PHs, \PHl, \PHh')$ les Frappes de Processus standards avec $\PHh' = \PHh$.
  et $r \in \PHl$ :
  \[\exists s \in \PHl, r \trans{\PH} s \Longleftrightarrow
    \exists s' \in \PHl, r \trans{\PHmerge(\PH)} s'\]
\end{theorem}

\begin{proof}
  On pose : $\PH' = \PHmerge(\PH)$.

  ($\Rightarrow$) Supposons qu'il existe $s \in \PHl$ tel que $r \trans{\PH} s$;
    cela signifie qu'une action $h \in \PHh$ est jouable dans $\PH$.
    Cette action est donc aussi jouable dans $\PH'$ car son frappeur et sa cible sont présents,
    d'où : $r \trans{\PH'} (r \play h)$.
    
  ($\Leftarrow$) Supposons qu'il existe $s' \in \PHl$ tel que $r \trans{\PH'} s'$ ;
    cela signifie qu'une action $g \in \PHh$ est jouable dans $\PH'$.
    Le frappeur et la cible de $g$ sont donc présents dans $r$.
    \begin{itemize}
      \item Si cette action n'est pas préemptée par une autre action dans $\PH$,
        elle est alors jouable et $r \trans{\PH} (r \play g)$ ;
      \item Si cette action est préemptée par une autre action $g'$ dans $\PH$,
        cela signifie que cette action $g'$ est jouable, et $r \trans{\PH} (r \play g')$.
    \end{itemize}
\end{proof}

\subsubsection{Analyse statique}
\seclabel{php-outils-as}

\stodo{Ref analyse statique chapitre 2}

Afin de permettre une étude efficace des Frappes de Processus standards de grande taille,
une analyse statique par interprétation abstraite avait été développée \stodo{ref thèse Loïc}.
L'ajout de classes de priorités au formalisme a pour conséquence d'en restreindre la dynamique,
mais n'ajoute aucun comportement supplémentaire.
Ainsi, pour tout modèle de Frappes de Processus avec $k$ classes de priorités,
il est toujours possible de réutiliser l'analyse statique par sur-approximation
en l'appliquant au modèle $\PHmerge(\PH)$.
Bien que toujours exacte, cette analyse pourra néanmoins être moins conclusive,
n'ayant pas été spécifiquement adaptée aux modèles comportant des classes de priorités.

En revanche, l'analyse statique par sous-approximation n'est plus valable,
car elle ne prend pas en compte les possibles préemptions entre actions qui rendent
impossibles certaines atteignabilités.
C'est pourquoi une nouvelle version de l'analyse statique par sous-approximation sera développée
au \chapref{phcanonique}
sur une classe particulière de Frappes de Processus avec 2 classes de priorités, appelées
Frappes de Processus canoniques.
Cette classe particulière n'autorise les actions avec une forte priorité que pour la mise à jour
des sortes coopératives.
Cependant, nous montrons aussi au \thmref{bisimulaplatissement}
que toutes Frappes de Processus avec un nombre quelconque de classes de priorités peut être traduit
en Frappes de Processus canoniques, et nous donnons une telle traduction à la
\defref{aplatissement}.

\subsubsection{Paramètres stochastiques}
\seclabel{php-outils-stocha}

\stodo{Ref stochasticité chapitre 2}

Il est théoriquement toujours possible d'utiliser des paramètres stochastiques
\stodo{ref thèse Loïc}
dans des Frappes de Processus avec $k$ classes de priorités,
en empêchant simplement la sensibilisation de toute action préemptée par une action
de priorité plus importante.
Cependant, un autre parallèle intéressant peut être tracé entre l'approche
par définition de classes de priorités
et l'approche par introduction de paramètres stochastiques.

L'ajout de paramètres stochastiques a pour but d'assigner un intervalle de tir temporel à
chaque action, afin de s'assurer (avec un certain niveau de confiance) que l'action sera
nécessairement tirée dans cet intervalle à partir du moment où elle est devenue jouable.
La simulation stochastique développée dans \stodo{ref thèse Loïc}
ne permet actuellement pas de prendre en compte des classes de priorités entre actions.
Il faudrait en effet pour cela raffiner la machine stochastique afin d'y intégrer des contraintes
supplémentaires concernant la jouabilité et la sensibilisation de chaque action.
Cependant, l'aplatissement proposé plus loin à la \defref{aplatissement}
devrait théoriquement permettre d'obtenir un modèle équivalent,
utilisable avec la simulation stochastique, à condition
d'attribuer à chaque action secondaire (\cad de priorité 2)
des paramètres stochastiques identiques à ceux de l'action originelle dont elle est issue,
et à chaque action primaire (\cad de priorité 1) une absorption de stochasticité infinie.

Par ailleurs, sous certaines conditions détaillées plus bas,
stipulant notamment qu'on puisse distinguer les intervalles de tir en différentes classes
qui ne se recouvrent pas,
il est possible d'approximer la modélisation avec des paramètres stochastiques à
l'aide de classes de priorités.
Ainsi, en associant une classe de priorités à chaque ensemble d'intervalles de tir,
la priorité la plus haute étant associée à la classe dont les intervalles sont les plus proches
de zéro,
on retrouve alors un modèle dont les caractéristiques dynamiques sont proches
du modèle initial.
En effet, le système de classes de priorités permet d'approcher une dynamique où
chaque intervalle est joué en priorité avant tous les suivants.

Cependant, il n'est évidemment pas possible d'atteindre le même niveau de précision avec un nombre
discret de classes de priorités qu'avec des intervalles de tir définis sur une ligne temporelle
continue.
Ainsi, il n'est pas possible de représenter fidèlement le recouvrement de deux intervalles de tir,
qui aurait pour conséquence de favoriser le tir d'une première action sans pour autant annuler
totalement la probabilité de tirer la seconde action.
À l'inverse, deux intervalles de tir qui ne se recouvrent pas devraient être associés à la même
classe de priorités s'ils sont tous deux recouverts par un troisième intervalle,
ce qui aura pour conséquence de mettre les trois actions sur un pied d'égalité, alors que les
paramètres stochastiques ne le permettent initialement pas.

Enfin, les phénomènes d'accumulation ou de retard ne sont pas pris en compte dans la modélisation
par classes de priorités.
En effet, si deux actions n'ont pas de sorte en commun, elles devraient dans l'idéal pouvoir
évoluer de façon indépendante, ce qui est notamment permis par la simulation stochastique
proposée dans \stodo{ref thèse loïc}.
En revanche, dans un formalisme avec classes de priorités, si l'une des actions est plus
prioritaire que l'autre, elle exercera tout de même sa préemption sur l'autre.
L'une des façons de pallier ce défaut est l'utilisation d'arcs neutralisants,
comme développé à la \secref{phan}.

\todo{Exemple ?}

