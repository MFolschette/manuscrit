\subsection{Frappes de Processus avec classes de priorités}
\seclabel{php}

\todo{Mise en perspective}

Pour tout entier naturel $k$ non nul,
les \emph{Frappes de Processus avec $k$ classes de priorités}
%(aussi appelées «~Frappes de Processus~» dans la suite, lorsque ce n'est pas ambigu),
sont des Frappes de Processus dont l'ensemble des actions est partitionné
en $k$ ensembles, chacun étant associé à une classe de priorité distincte.
Cela signifie qu'une action est jouable dans un état si et seulement si,
en plus de la condition de la présence du frappeur et de la cible,
il n'existe aucune autre action appartenant à une classe de priorité plus grande
qui soit aussi jouable dans cet état.
Il est à noter que les classes de priorités sont étiquetées de façon décroissante par les entiers de
l'ensemble $\segm{1}{k}$ en fonction de l'importance de la priorité ;
autrement dit, la classe de priorités 1 contient les actions les plus prioritaires,
ne pouvant jamais être préemptées,
tandis que la jouabilité d'une action de la classe de priorité $k$ ne peut pas empêcher le jeu
d'une autre action.

Cette modélisation permet notamment de distinguer les actions en fonction 
de différents critères comme
leur vitesse d'exécution (les actions les plus rapides étant jouées en priorité),
ou tout autre paramètre permettant de déterminer l'existence de la préemption d'une action
en fonction de la possibilité d'en jouer une autre.
L'application la plus poussée de cette utilisation consisterait à
classer les actions d'un modèle en fonction d'un tel critère,
et à attribuer à chaque classe de priorité une action unique en fonction de ce classement,
afin de créer un ordre total entre toutes les actions défini par leurs priorités.
%afin de rendre compte de la priorité de chaque action en fonction de chaque autre.

De même, ces classes de priorités permettent de prendre en compte des comportements non biologiques
inhérents à la modélisation.
Il est par exemple possible de donner une priorité différente aux
actions qui n'ont pas de sens biologique propre
--- mais dont ce sens émerge uniquement dans leur relation avec d'autres actions.
L'application la plus immédiate de ce cas est celle des actions de mise à jour
des sortes coopérative \todo{ref PH canonique},
où une classe de priorités supérieure offre l'avantage de supprimer les effets d'entrelacement,
et ainsi de simuler le comportement d'une véritable porte logique sans décalage temporel \todo{ref}.

Cette représentation basée sur des classes de priorités permet de modéliser un système
dont les actions peuvent être distinguées en plusieurs classes en fonction de leur importance,
de leur vitesse d'exécution, ou encore d'autres facteurs leur donnant prévalence sur d'autres.
Chaque action peut donc en préempter un ensemble d'autres en fonction de sa classe de priorités.
Cela permet une représentation compacte, des rapports de priorités entre actions
ou, autrement dit, de leur ordonnancement,
qui présente néanmoins quelques lacunes.
Les phénomènes d'accumulation, notamment, n'y sont pas représentés ;
un cycle d'actions prioritaires ne peut jamais être interrompu par une action moins prioritaire,
menant à un cycle infini et pouvant contredire la réalité biologique.
De plus, les classes de priorités définies pour un modèle sont invariables;
certains modèles pourraient cependant nécessiter l'évolution de certaines classes de priorités
en fonction de la présence ou de l'absence d'un composant dans un état donné.
Enfin, elles peuvent ne pas permettre la précision nécessaire à une représentation fidèle de
certains modèles, notamment lorsqu'il est nécessaire de définir des préemptions ponctuelles
comme le permettent les Frappes de Processus avec arcs neutralisants
présentées à la \secref{phan}.

\todo{Schéma exemple}

\begin{definition}[Frappes de Processus avec $k$ classes de priorités]
\deflabel{php}
  Si $k \in \sN^*$, les \emph{Frappes de Processus avec $k$ classes de priorités} sont définies
  par un triplet $\PH = (\PHs; \PHl; \PHh^{\langle k \rangle})$,
  où $\PHh^{\langle k \rangle} = (\PHh^{(1)}; \dots; \PHh^{(k)})$ est un $k$-uplet, et :
  \begin{itemize}
    \item $\PHs \DEF \{a, b, \dots\}$ est l'ensemble fini et dénombrable des \emph{sortes} ;
    \item $\PHl \DEF \bigtimes{a \in \PHs} \PHl_a$ est l'ensemble fini des \emph{états},
      où $\PHl_a = \{a_0, \ldots, a_{l_a}\}$ est l'ensemble fini et dénombrable
      des \emph{processus} de la sorte $a \in \PHs$ et $l_a \in \sN^*$.
      Chaque processus appartient à une unique sorte :
      $\forall (a_i; b_j) \in \PHl_a \times \PHl_b, a \neq b \Rightarrow a_i \neq b_j$ ;
    \item pour tout $n \in \llbracket 1; k \rrbracket$,
      $\PHh^{(n)} \DEF \{\PHfrappe{a_i}{b_j}{b_l} \mid (a; b) \in \PHs^2 \wedge
      (a_i; b_j; b_l) \in \PHl_a \times \PHl_b \times \PHl_b \wedge
      b_j \neq b_l \wedge a = b \Rightarrow a_i = b_j \}$ est l'ensemble fini
      des \emph{actions de priorité $n$}.
  \end{itemize}
  On note $\PHh \DEF \bigcup_{n \in \segm{1}{k}} \PHh^{(n)}$ l'ensemble de toutes les actions
  et, pour tout $n \in \sN^*$ et $h \in \PHh^{(n)}$, $\prio(h) \DEF n$.
\end{definition}
%
\noindent
On réutilise de surcroît les notations définies à la \secref{ph} concernant les états et
l'extraction de la sorte d'un processus.

%La sorte d'un processus $a_i$ est donnée par $\PHsort(a_i) = a$.
%Étant donné un état $s \in \PHl$, le processus de la sorte $a \in \PHs$ présent dans $s$ est donné
%par $\PHget{s}{a}$, \cad la coordonnée correspondant à $a$ dans l'état $s$.
%Si $a_i \in \PHl_a$, nous définissons la notation : $a_i \in s \EQDEF \PHget{s}{a} = a_i$.

À l'instar de la \secref{ph}, il faut définir un opérateur de jouabilité
pour déterminer la dynamique des Frappes de Processus avec $k$ classes de priorités.
Cependant, à l'inverse de celui des Frappes de Processus standard (\defref{fopph})
il faut ici prendre en compte la possible présence d'actions jouables appartenant à des
classes de priorités supérieures.
Pour cela, il est suffisant de vérifier que le frappeur et la cible de toute action
de priorité plus importante ne sont pas simultanément présents.
En effet, prenons deux actions $g, h \in \PHh$ avec : $\prio(g) < \prio(h)$, et
un état $s \in \PHl$ tel que $\frappeur{g} \in s \wedge \cible{g} \in s$ ;
Deux cas de figures sont alors possibles :
\begin{itemize}
  \item l'action $g$ est jouable dans $s$ --- autrement dit, aucune autre action de priorité plus
    importante ne la préempte -- et elle préempte $h$ en conséquence,
  \item l'action $g$ n'est pas jouable dans $s$, ce qui signifie qu'elle est préemptée par une
    action de priorité plus importante, qui préempte alors aussi l'action $h$.
\end{itemize}
Dans les deux cas, $h$ n'est pas jouable, ce qui montre qu'il est suffisant de n'observer
que la présence simultanée du frappeur et de la cible de chaque action de priorité supérieure
pour déterminer la jouabilité de $h$.
Nous obtenons alors l'opérateur de jouabilité donné à la \defref{fopphp}.

\begin{definition}[Opérateur de jouabilité ($\Fopsymbol_\Fopphpsubsymbol : \PHh \rightarrow \F$)]
\deflabel{fopphp}
  L'opérateur de jouabilité des Frappes de Processus avec $k$ classes de priorités est défini par :
  \[\forall h \in \PHh, \Fopphp{h} \equiv \hitter{h} \wedge \target{h} \wedge
    \left( \bigwedge_{\substack{g \in \PHh^{(n)}\\n < \prio(h)}}
    \neg \left( \hitter{g} \wedge \target{g} \right) \right)\]
\end{definition}
%\todo{Est-ce une bonne idée ? L'opérateur pour la traduction est différent.}

\todo{À faire : équivalence avec les automates synchronisés avec un seul bond (cf. def de TSI)}

\todo{Fonctionne encore : points fixes et analyse stochastique (avec adaptation : préemtion
  ou suppression des priorités avec contrainte : $r$ inférieur avec priorité supérieure.}

\todo{Ne fonctionne plus : analyse statique, mais adaptée pour certains cas précis (cf. PHcanonique)}

\todo{Traduction vers PHcanonique}
