\section{Les Frappes de Processus standards}

\subsection{Définition}
\seclabel{ph}

Les Frappes de Processus permettent une modélisation atomique des interactions entre composants.
\Defref{ph}
\todo{Description}

\begin{definition}[Frappes de Processus]
\deflabel{ph}
  Les \emph{Frappes de Processus} sont définies
  par un triplet $\PH = (\PHs; \PHl; \PHh)$, où :
  \begin{itemize}
    \item $\PHs \DEF \{a, b, \dots\}$ est l'ensemble fini et dénombrable des \emph{sortes} ;
    \item $\PHl \DEF \underset{a \in \PHs}{\times} \PHl_a$ est l'ensemble fini des \emph{états},
      où $\PHl_a = \{a_0, \ldots, a_{l_a}\}$ est l'ensemble fini et dénombrable
      des \emph{processus} de la sorte $a \in \PHs$ et $l_a \in \sN^*$.
      Chaque processus appartient à une unique sorte :
      $\forall (a_i; b_j) \in \PHl_a \times \PHl_b, a \neq b \Rightarrow a_i \neq b_j$ ;
    \item $\PHh \DEF \{\PHfrappe{a_i}{b_j}{b_l} \mid (a; b) \in \PHs \times \PHs \wedge
      (a_i; b_j; b_l) \in \PHl_a \times \PHl_b \times \PHl_b \wedge
      b_j \neq b_l \wedge a = b \Rightarrow a_i = b_j \}$ est l'ensemble fini des \emph{actions}.
  \end{itemize}
\end{definition}
%
\noindent
On note $\PHproc \DEF \bigcup_{a \in \PHs} \PHl_a$ l'ensemble de tous les processus.
La sorte d'un processus $a_i$ est donnée par $\PHsort(a_i) = a$ ;
on définit aussi l'ensemble des sortes d'un ensemble de processus par :
$\forall A \subset \Proc, \sortes{A} = \{ \sorte{p} \mid p \in A \}$.
Étant donné un état $s \in \PHl$, le processus de la sorte $a \in \PHs$ présent dans $s$ est donné
par $\PHget{s}{a}$, \cad la coordonnée correspondant à $a$ dans l'état $s$.
Si $a_i \in \PHl_a$, nous définissons la notation : $a_i \in s \EQDEF \PHget{s}{a} = a_i$.
Pour toute action $h = \PHfrappe{a_i}{b_j}{b_k} \in \PHh$,
$a_i$ est appelé le \emph{frappeur}, $b_j$ la \emph{cible} et $b_k$ le \emph{bond} de $h$,
et on note : $\hitter{h} = a_i$, $\target{h} = b_j$ et $\bounce{h} = b_k$.

Une séquence d'actions $A$,
on note $\sortes{A}$ l'ensemble des sortes dont au moins un processus figure dans $A$
en tant que frappeur, cible ou bond d'une action.
De plus, pour toute sorte $a$,
on note $\prem{a}{A}$ le premier processus référencé de $a$,
$\sup{A}$ l'ensemble de tous ces premiers processus,
$\der{a}{A}$ le dernier processus référencé de $a$
et $\fin{A}$ l'ensemble de tous ces derniers processus.
Ces notations sont formellement définies dans la \defref{premder}.

\begin{definition}[$\premsymbol$, $\dersymbol$, $\suppsymbol$ et $\finsymbol$]
\deflabel{premder}
  Pour toute séquence d'actions $A$ et pour toute sorte $a$,
  $\prem{a}{A}$ est le premier processus de $a$ référencé dans $A$,
  en tant que frappeur ou en tant que cible,
  et $\der{a}{A}$ en est le dernier,
  en tant que frappeur ou en tant que bond.
  \begin{align}
  \eqlabel{prem}
    \prem{a}{A} &=
      \begin{cases}
        \varnothing & \text{si } a \notin \sortes{A}, \\
        \hitter{A_m} & \text{si } m = \min\{ n \in \indexes{A} \mid a \in \sortes{A_n} \}
          \wedge \sorte{\hitter{A_m}} = a, \\
        \target{A_m} & \text{sinon si } m = \min\{ n \in \indexes{A} \mid a \in \sortes{A_n} \}
          \wedge \sorte{\target{A_m}} = a \enspace;
      \end{cases} \\
  \eqlabel{der}
    \der{a}{A} &=
      \begin{cases}
        \varnothing & \text{si } a \notin \sorts(A), \\
        \bounce{A_m} & \text{si } m = \max\{ n \in \indexes{A} \mid a \in \sortes{A_n} \}
          \wedge \sorte{\bounce{A_m}} = a, \\
        \hitter{A_m} & \text{sinon si } m = \max\{ n \in \indexes{A} \mid a \in \sortes{A_n} \}
          \wedge \sorte{\hitter{A_m}} = a \enspace.
      \end{cases}
  \end{align}

  Pour toute séquence d'actions $A$,
  $\supp{A}$ et $\fin{A}$ renvoient respectivement à l'ensemble des premiers
  et derniers processus de $A$ pour toutes les sortes qui y figurent.
  \begin{align}
  \eqlabel{supp}
    \supp{A} &= \{ p \in \Proc \mid \sorte{p} \in \sorte{A} \wedge
      p = \prem{\sort(p)}{\delta} \} \enspace, \\
  \eqlabel{fin}
    \fin{A} &= \{ p \in \Proc \mid \sorte{p} \in \sorte{A} \wedge
      p = \fin{\sort(p)}{\delta} \} \enspace.
  \end{align}
\end{definition}


La \defref{substate} établit la notion de sous-état sur un ensemble de sortes,
\cad un ensemble de processus qui sont deux à deux de sortes différentes,
ce qui permet de ne considérer qu'une partie d'un état complet.
Nous notons qu'un état est \textit{a fortiori} un sous-état : $\PHl \subset \PHsubl$.
Le recouvrement d'un état $s$ par un processus $a_i$ est formalisé à la \defref{statecap}
par un état identique à $s$, sauf pour le processus de $a$ qui a été remplacé par $a_i$,
ce qui permettra de définir la dynamique des Frappes de Processus %avec $k$ classes de priorités
à la \defref{play}.
La définition de recouvrement est aussi étendue à un sous-ensemble,
autrement dit, un ensemble de processus contenant au plus un processus par sorte.

\begin{definition}[Sous-états ($\PHsublize{\PHl}$)]
\deflabel{substate}
  Si $S \subset \PHs$ est un ensemble de sortes, un sous-ensemble sur $S$ est un élément de :
  $\PHsubl[\PHl]_S \DEF \bigtimes{a \in S} \PHl_a$.
  L'ensemble de tous les sous-ensembles est noté :
  $\PHsubl[\PHl] \DEF \bigcup_{S \in\powerset(\PHs)} \PHsubl[\PHl]_S$.
  
  \noindent
  De plus, si $\mysigma \in \PHsubl[\PHl]$ et $s \in \PHl$, on note alors :
  \[\mysigma \subseteq s \EQDEF \forall a_i \in \Proc, a_i \in \mysigma \Rightarrow a_i \in s
    \enspace.\]
  
  \noindent
  Enfin, si $S \subset \PHs$, on note :
  $\PHsublset_S = \{ \toset{ps} \subset \Proc \mid ps \in \PHsubl_S \}$
  et
  $\PHsublset = \{ \toset{ps} \subset \Proc \mid ps \in \PHsubl \}$.
\end{definition}
\todo{Définir la notation $\toset{x}$}
%
\begin{definition}[Recouvrement ($\recouvre : \PHl \times \PHproc \rightarrow \PHl$)]
\deflabel{statecap}
  Étant donné un état $s \in \PHl$ et un processus $a_i \in \PHproc$,
  $(s \recouvre a_i)$ est l'état défini par :
  $\PHget{(s \recouvre a_i)}{a} = a_i \wedge \forall b \neq a, \PHget{(s \recouvre a_i)}{b} = \PHget{s}{b}$.
  On étend de plus cette définition à un ensemble de processus
  par le recouvrement de l'état par chaque processus,
  à condition que les processus de l'ensemble soient tous de sortes différentes :
  $\forall ps \in \PHsublset, s \recouvre ps = s \underset{a_i \in ps}{\recouvre} a_i$.
\end{definition}

Une propriété de jouabilité telle que décrite à la \defref{ppl}
est équivalente à une formule booléenne dont les atomes sont des processus dans $\Proc$.
Le langage des propriétés de jouabilité permet de décrire la présence d'une configuration
de processus actifs dans un état donné.
Il permet notamment de décrire en termes formels la jouabilité d'une action,
ce qui est immédiatement mis en pratique dans la \defref{fopph}.

\begin{definition}[Propriété de jouabilité ($\F$)]
  \label{def:ppl}
  Une \emph{propriété de jouabilité} est un élément du langage $\F$ défini \todo{inductivement ?} par :
  \begin{itemize}
    \item $\top$ et $\bot$ appartiennent à $\F$ ;
    \item si $a \in \PHs$ et $a_i \in \PHl_a$, alors $a_i$ appartient à $\F$
      et est appelé un \emph{atome} ;
    \item si $P \in \F$ et $Q \in \F$,
      alors $\neg P$, $P \wedge Q$ et $P \vee Q$ appartiennent à $\F$.
  \end{itemize}
%
  Si $P \in \F$ est une propriété de jouabilité et $\mysigma \in \PHsubl$ est un sous-ensemble,
  on note $\Feval{P}{\mysigma}$ l'\emph{évaluation} de $P$ dans $\mysigma$:
  \begin{itemize}
    \item si $P = a_i \in \PHl_a$ est un atome, avec $a \in \PHs$,
      alors $\Feval{a_i}{\mysigma}$ est vraie si et seulement si $a_i \in \mysigma$ ;
    \item si $P$ n'est pas un atome, alors $\Feval{P}{\mysigma}$ est vraie si et seulement si
      on peut l'évaluer récursivement comme vraie en utilisant la sémantique habituelle des
      opérateurs $\neg$, $\wedge$ et $\vee$ et des constantes $\top$ et $\bot$.
  \end{itemize}
%
  Une fonction $\Fopsymbol : \PHh \rightarrow \F$ associant à toute action une propriété de jouabilité
  est appelée un \emph{opérateur de jouabilité}.
\end{definition}

Étant donné que ce langage n'utilise que des opérateur logiques classiques,
les propriétés de la logique booléenne sont applicables aux propriétés de jouabilité,
à savoir celles concernant la distributivité, l'associativité et la commutativité,
ainsi que les lois de De Morgan concernant la négation.

Il en résulte notamment la propriété suivante, permettant d'évaluer la négation d'un atome,
et qui dérive naturellement du fait que si un processus n'est pas actif dans un état donné,
cela signifie alors qu'un autre processus de la même sorte l'est :
\[\forall a \in \PHs, \forall a_i \in \PHl_a, \forall \mysigma \in \PHsubl,
  \Feval{\neg a_i}{\mysigma} \Leftrightarrow
  \Feval{\bigvee_{\substack{a_j \in \PHl_a\\a_j \neq a_i}} a_j}{\mysigma}\]

Enfin, on note dans la suite :
\[\forall A \in \PHsublset, \Fconj{A} \equiv \bigwedge_{p \in A} p \enspace.\]

\todo{Gluer}

\begin{definition}[Opérateur de jouabilité ($\Fopsymbol : \PHh \rightarrow \F$)]
\deflabel{fopph}
  L'opérateur de jouabilité des Frappes de Processus est défini par :
  \[\forall h \in \PHh, \Fop{h} \equiv \hitter{h} \wedge \target{h} \enspace.\]
\end{definition}

\begin{definition}[Dynamique des Frappes de Processus ($\PHtrans$)]
\deflabel{play}
  Une action $h \in \PHh$ est dite \emph{jouable}
  dans l'état $s \in \PHl$ si et seulement si :
  $\Feval{\Fop{h}}{s}$.
%  $\target{h} \in s \wedge \Feval{\Fop{h}}{s}$.
  Dans ce cas, $(s \PHplay h)$ est l'état résultant du jeu de l'action $h$ dans $s$,
  et on le définit par : $(s \PHplay h) = s \recouvre \bounce{h}$.
  De plus, on note alors : $s \PHtrans (s \PHplay h)$.

  Si $s \in \PHl$, un \emph{scénario} $\delta$ dans $s$
  est une séquence d'actions de $\PHh$ qui peuvent être jouées successivement dans $s$.
  L'ensemble de tous les scénarios dans $s$ est noté $\Sce(s)$.
\end{definition}



\subsection{Sortes coopératives}
\seclabel{sc}

\TODO


\subsection{Modelling cooperation}
\label{ssec:cooperation}

\begin{comment}
Cooperation between processes to make another process bounce can be expressed in PH by building a \emph{cooperative sort}, as described in \cite{PMR10-TCSB}.
\pref{fig:ph-livelock} shows an example of cooperation between processes $a_1$ and $b_1$ to make $c_0$ bounce to $c_1$:
a cooperative sort $ab$ is defined with 4 processes (one for each sub-state of the presence of processes $a_1$ and $b_1$).
For the sake of clarity, the processes of $ab$ are indexed using the sub-state they represent.
Hence, $ab_{10}$ represents the sub-state $\PHstate{a_1,b_0}$, and so on.
Each process of sort $a$ and $b$ hit $ab$ to make it bounce to the process reflecting the status of the sorts $a$ and $b$
(\eg $\PHfrappe{a_1}{ab_{00}}{ab_{10}}$ and $\PHfrappe{a_1}{ab_{01}}{ab_{11}}$).
Then, to represent the cooperation between $a_1$ and $b_1$, the process $ab_{11}$ hits $c_0$ to make it bounce to $c_1$ instead of independent hits from $a_1$ and $b_1$.

We note that cooperative sorts are standard PH sorts and do not involve any
special treatment regarding the semantics of related actions.
Furthermore, it is possible to “factorise” cooperative sorts in order to decrease the number of processes created within each cooperative sort.
For example, if three processes $x_1$, $y_1$ and $z_1$ cooperate,
it is preferable to create a cooperative sort $xy$ with 4 processes to state the presence of $x_1$ and $y_1$
and a second cooperative sort $xyz$ with 4 processes to state the presence of $xy_{11}$ and $z_1$,
rather than a unique cooperative sort with 8 processes stating the presence of $x_1$, $y_1$ and $z_1$.
This “factorisation” allows to prevent the combinatorial explosion of the number of processes in cooperative sorts,
especially for cooperations between more than three processes.
It may have computational consequences as the static analysis method developed in~\pref{sec:sa} does not suffer from the number of sorts but from the number of processes in each sort.

The construction of cooperation in PH allows to encode any Boolean function between cooperating processes \cite{PMR10-TCSB}.
Due to the introduction of priorities into the PH framework,
it is possible to build cooperations with no temporal shift by defining actions updating the cooperative sorts with the highest class of priority.
This allows to gain the same expressivity in PH than in Boolean networks, as stated in \pref{sec:dn}.
The aim of this paper is to allow the static analysis of the dynamics to be handled on PH models involving such prioritised actions updating cooperative sorts.
\end{comment}



\subsection{Analyse statique}

\todo{Rappels sur les résultats d'analyse statique (cf. MSCS'10)}

\todo{+ Points fixes}



\subsection{Analyse stochastique}

\todo{Rappels rapides ?}
