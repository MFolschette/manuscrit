\section{Les Frappes de Processus standards}

Cette section définit les Frappes de Processus standards
telles qu'elles ont été formalisées par \citeasnoun{PMR10-TCSB}.
Les Frappes de Processus offrent une représentation discrète, asynchrone et indéterministe
avec une définition atomique des interactions entre les différents composants du modèle.
Elles sont particulièrement adaptées aux représentations des réseaux de régulation biologiques
bien qu'elles soient assez générales pour potentiellement permettre des applications plus
larges en informatique ou dans d'autres domaines.

Nous donnerons tout d'abord à la \secref{ph} une définition des Frappes de Processus standards
%accompagnée d'une discussion,
ainsi qu'un certain nombre de définitions formelles supplémentaires
nécessaires pour la suite de ce manuscrit.
Nous détaillons ensuite à la \secref{sc} le mécanisme particulier des sortes coopératives
tel qu'il avait été formalisé dans les travaux de Loïc Paulevé,
et nous montrerons qu'il permet de représenter l'action conjointe de plusieurs composants,
mais avec certains défauts difficiles à corriger dans cette version du formalisme.
Enfin, nous aborderons brièvement les travaux précédent
concernant l'analyse statique (\secref{ph-as-pf}) qui permet d'obtenir des résultats
sur l'ensemble des états stables ou l'atteignabilité d'un niveau local au sein d'un modèle,
et concernant l'ajout de paramètres stochastiques (\secref{ph-stocha})
dans le but d'introduire une composante temporelle continue dans les Frappes de Processus.



\subsection{Définition}
\seclabel{ph}

Les \emph{Frappes de Processus standards} telles que données à la \defref{ph},
aussi appelées \textit{Process Hitting},
ou plus simplement \emph{Frappes de Processus} dans ce chapitre,
permettent une modélisation atomique et asynchrone des interactions entre composants.
Un modèle de Frappes de Processus standards comporte un nombre fini de \emph{sortes}
généralement notées $a$, $b$, $c$...
Celles-ci permettent de représenter les différentes entités du modèle,
qu'il s'agisse de composant ayant une réalité biologique (gène, protéine...)
ou d'entités nécessaire à la modélisation (comme les sortes coopératives
qui seront décrites à la \secref{sc}).
Chaque sortes contient plusieurs \emph{processus},
qui représentent les différentes
niveaux d'expression discrets accessibles par la sorte,
et qui sont notés $a_i$
où $a$ est le nom de la sorte et $i$ l'indice du processus dans cette sorte.
Un processus n'appartient qu'à une unique sorte.
Chaque processus est dit \emph{actif} s'il représente le niveau d'expression
dans lequel doit se trouver sa sorte à un certain moment.
Un \emph{état} du modèle est donc décrit par l'ensemble des processus actifs à un instant donné,
avec exactement un processus actif par sorte
---~afin de ne pas sur-représenter ou sous-représenter le niveau d'expression courant d'une sorte.

La dynamique est introduite dans les Frappes de Processus par des \emph{actions}
qui permettent de modifier le processus actif d'une sorte,
à la condition éventuelle qu'un processus donné d'une autre sorte soit présent.
Une action consiste donc en un triplet de processus $\PHfrappe{a_i}{b_j}{b_k}$
qui se lit : «~$a_i$ frappe $b_j$ pour le faire bondir en $b_k$~»,
et qui signifie que si, dans un état donné, les processus $a_i$ et $b_j$ sont
tous les deux présents, alors il est possible d'activer $b_k$ (et de désactiver $b_j$)
dans l'état suivant.
Autrement dit, le processus actif de la sorte $b$ peut \emph{bondir}
de $b_j$ à $b_k$ à condition que $a_i$ soit actif ;
lorsque cela arrive, on dit qu'on a \emph{joué} l'action $\PHfrappe{a_i}{b_j}{b_k}$.
Par convention, on contraint de plus que $b_j \neq b_k$ pour assurer que le jeu d'une action
provoque bien un changement de processus actif.
Il est aussi possible de définir une auto-action, où $a_i = b_j$ (et nécessairement $a = b$),
qui permet de représenter le cas particulier où le processus $b_j$ peut bondir en $b_k$
sans autre condition.

Les Frappes de Processus sont conçues comme un formalisme
à temps discret asynchrone, ce qui signifie que
l'évolution d'un tel modèle est modélisée par une succession de pas de temps discrets
qui représentent la succession des états du modèle,
et exactement une action est jouée entre deux états successifs.
Cela implique qu'un seul processus actif à la fois peut bondir entre deux
pas de temps successifs, et donc qu'une seule sorte peut évoluer entre deux états.
De plus, cela rend la dynamique Frappes de Processus indéterministe,
car à tout état du modèle peuvent correspondre plusieurs états successeurs
dans le cas où plusieurs actions peuvent y être jouées.
Enfin, nous notons que si aucune action n'est jouable dans un état, alors celui-ci
ne possède pas de successeurs et le modèle ne peut plus évoluer.

\begin{definition}[Frappes de Processus standards]
\deflabel{ph}
  Les \emph{Frappes de Processus standards} sont définies
  par un triplet $\PH = (\PHs; \PHl; \PHh)$, où :
  \begin{itemize}
    \item $\PHs \DEF \{a, b, \dots\}$ est l'ensemble fini et dénombrable des \emph{sortes} ;
    \item $\PHl \DEF \bigtimes{a \in \PHs} \PHl_a$ est l'ensemble fini des \emph{états},
      où $\PHl_a = \{a_0, \ldots, a_{l_a}\}$ est l'ensemble fini et dénombrable
      des \emph{processus} de la sorte $a \in \PHs$ et $l_a \in \sN^*$,
      chaque processus appartenant à une unique sorte :
      $\forall (a_i; b_j) \in \PHl_a \times \PHl_b, a \neq b \Rightarrow a_i \neq b_j$ ;
    \item $\PHh \DEF \{\PHfrappe{a_i}{b_j}{b_k} \mid (a; b) \in \PHs \times \PHs \wedge
      (a_i; b_j; b_k) \in \PHl_a \times \PHl_b \times \PHl_b \wedge
      b_j \neq b_k \wedge a = b \Rightarrow a_i = b_j \}$ est l'ensemble fini des \emph{actions}.
  \end{itemize}
\end{definition}
%
\noindent
On note $\PHproc \DEF \bigcup_{a \in \PHs} \PHl_a$ l'ensemble de tous les processus.
La sorte d'un processus $a_i$ est donnée par $\PHsort(a_i) = a$ ;
on définit aussi l'ensemble des sortes d'un ensemble de processus par :
$\forall A \subset \Proc, \sortes{A} = \{ \sorte{p} \mid p \in A \}$.
Étant donné un état $s \in \PHl$, le processus de la sorte $a \in \PHs$ présent dans $s$ est donné
par $\PHget{s}{a}$, \cad la coordonnée correspondant à $a$ dans l'état $s$.
Si $a_i \in \PHl_a$, nous définissons la notation : $a_i \in s \EQDEF \PHget{s}{a} = a_i$ ;
par extension, si $ps \subset \Proc$, on écrit alors :
$ps \subseteq s \EQDEF \forall p \in ps, p \in s$.
Pour toute action $h = \PHfrappe{a_i}{b_j}{b_k} \in \PHh$,
$a_i$ est appelé le \emph{frappeur}, $b_j$ la \emph{cible} et $b_k$ le \emph{bond} de $h$,
et on note : $\hitter{h} = a_i$, $\target{h} = b_j$ et $\bounce{h} = b_k$.

\begin{example}
\exlabel{metazoan-ph-nocoop}
  La figure \figref{metazoan-ph-nocoop} illustre une représentation possible des
  Frappes de Processus standards.
  Le modèle $\PH = (\PHs, \PHl, \PHh)$ représenté comporte trois sortes :
  $\PHs = \{ a, c, f \}$.
  Chaque sorte comporte exactement deux processus :
  \[\PHl_a = \{ a_0, a_1 \} \enspace;\quad
    \PHl_b = \{ b_0, b_1 \} \enspace;\quad
    \PHl_f = \{ f_0, f_1 \} \enspace.\]
  On peut notamment en déduire le nombre total d'états du système :
  $\card{\PHl} = 2^3 = 8$.
  Enfin, ce modèle comporte 7 actions :
  \begin{align*}
    \PHh = \{\qquad
      \PHfrappe{c_1}{a_1}{a_0}\quad, && \PHfrappe{c_0}{a_0}{a_1}\quad,& \\
      \PHfrappe{c_1}{c_1}{c_0}\quad, && \PHfrappe{f_1}{c_0}{c_1}\quad,& \\
      \PHfrappe{f_1}{a_0}{a_1}\quad, && \PHfrappe{f_0}{c_1}{c_0}\quad,& \\
      \PHfrappe{f_1}{f_1}{f_0}\quad\; &&& 
    \qquad\}
  \end{align*}
  
  Ces Frappes de Processus représentent un modèle simplifié du mécanisme
  de segmentation des métazoaires qui permet par exemple de décrire la production de rayures
  chez les drosophiles.
  Il a été originellement établi \textit{in silico} par \citeasnoun{MSB4100192}
  à l'aide d'un formalisme à base d'équations différentielles,
  et le modèle présenté ici est inspiré du modèle proposé par \citeasnoun{PMR10-TCSB}.
  
  Les trois sortes $a$, $b$ et $c$ de ce modèle représentent différents gènes du système,
  que nous qualifierons d'\emph{actifs} dans le reste de ce document lorsqu'ils seront à l'état 1.
  La production de pigment est déclenchée par le produit du gène $a$,
  et une succession d'activations de celui-ci permet donc de produire des rayures.
  Pour que celles-ci soient régulières, il est donc nécessaire que la durée d'activation
  de $a$ soit constante, et que la durée entre deux activations le soit aussi.
  Ce mécanisme est réglé par le gène $c$ qui inhibe à la fois le gène $a$ à intervalles réguliers,
  et s'inhibe lui-même afin d'avoir le rôle d'une horloge.
  Enfin, le procédé complet est dirigé par le gène $f$ qui, lorsqu'il est actif,
  permet la progression d'un front au niveau duquel les pigments sont déposés.
  Ce gène peut aussi s'auto-inhiber après une certaine période, faisant cesser
  l'oscillation de l'horloge et ainsi la production de rayures.
  
  \begin{figure}[ht]
  \begin{center}
  \scalebox{1.5}{\begin{tikzpicture}
    \TSort{(0,4)}{c}{2}{l}
    \TSort{(1,1)}{f}{2}{l}
    \TSort{(3,4)}{a}{2}{r}
    
    \TAction{c_1}{a_1.west}{a_0.north west}{}{right}
    \TAction{f_1}{c_0.west}{c_1.south west}{bend left=50, in=90}{left}
    \TAction{c_1}{c_1.west}{c_0.north west}{selfhit}{right}
    \TAction{f_1.north east}{f_1.south east}{f_0.north east}%
      {selfhit, min distance=30, bend left, out=150, in=90}{left}
    \TAction{f_0.east}{c_1.south east}{c_0.north east}{bend right=80, in=-120}{left}
    
    % Fausse coopération
    \TAction{f_1.north}{a_0.south west}{a_1.south west}{bend left=20}{left}
    \TAction{c_0}{a_0.west}{a_1.south}{}{left}
    
    \TState{f_1, a_0, c_0}
  \end{tikzpicture}}
  \caption{\figlabel{metazoan-ph-nocoop}%
    Un exemple de Frappes de Processus standards.
    Les sortes sont représentées par des rectangles arrondis 
    contenant des cercles représentant les processus.
    Ainsi, le processus $a_1$ est représenté par le cercle marqué «~1~»
    dans le rectangle étiqueté «~$a$~», etc.
    Chaque action est de plus symbolisée par un couple de flèches,
    l'une en trait plein et l'autre en pointillés ;
    par exemple, l'action $\PHfrappe{c_1}{a_1}{a_0}$
    est représentée par une flèche pleine entre les processus $c_1$ et $a_1$
    suivie d'une flèche en pointillés entre $a_1$ et $a_0$.
    Enfin, les processus grisés représentent un état possible
    pour ces Frappes de Processus : $\etat{a_0, c_0, f_1}$, qui peut aussi faire office
    d'état initial pour ce modèle.
  }
  \end{center}
  \end{figure}
\end{example}

Les séquences d'actions ont un rôle particulier pour les Frappes de Processus.
Elles permettent notamment d'abstraire une dynamique locale en se concentrant
sur la conséquence plutôt que sur la cause,
et seront notamment utiles pour la méthode d'analyse statique développée
au \chapref{phcanonique}.
Pour toute séquence d'actions $A$,
on note $\sortes{A}$ l'ensemble des sortes dont au moins un processus figure dans $A$
en tant que frappeur, cible ou bond d'une action.
De plus, pour toute sorte $a$,
on note $\prem{a}{A}$ le premier processus référencé de $a$,
$\sup{A}$ l'ensemble de tous ces premiers processus,
$\der{a}{A}$ le dernier processus référencé de $a$
et $\fin{A}$ l'ensemble de tous ces derniers processus.
Ces notations sont formellement définies dans la \defref{premder}.

\begin{definition}[$\premsymbol$, $\dersymbol$, $\suppsymbol$ et $\finsymbol$]
\deflabel{premder}
  Pour toute séquence d'actions $A$ et pour toute sorte $a$,
  $\prem{a}{A}$ est le premier processus de $a$ référencé dans $A$,
  en tant que frappeur ou en tant que cible,
  et $\der{a}{A}$ en est le dernier,
  en tant que frappeur ou en tant que bond.
  \begin{align}
  \eqlabel{prem}
    \prem{a}{A} &=
      \begin{cases}
        \varnothing & \text{si } a \notin \sortes{A}, \\
        \hitter{A_m} & \text{si } m = \min\{ n \in \indexes{A} \mid a \in \sortes{A_n} \}
          \wedge \sorte{\hitter{A_m}} = a, \\
        \target{A_m} & \text{sinon si } m = \min\{ n \in \indexes{A} \mid a \in \sortes{A_n} \}
          \wedge \sorte{\target{A_m}} = a \enspace;
      \end{cases} \\
  \eqlabel{der}
    \der{a}{A} &=
      \begin{cases}
        \varnothing & \text{si } a \notin \sorts(A), \\
        \bounce{A_m} & \text{si } m = \max\{ n \in \indexes{A} \mid a \in \sortes{A_n} \}
          \wedge \sorte{\bounce{A_m}} = a, \\
        \hitter{A_m} & \text{sinon si } m = \max\{ n \in \indexes{A} \mid a \in \sortes{A_n} \}
          \wedge \sorte{\hitter{A_m}} = a \enspace.
      \end{cases}
  \end{align}

  Pour toute séquence d'actions $A$,
  $\supp{A}$ et $\fin{A}$ renvoient respectivement à l'ensemble des premiers
  et derniers processus de $A$ pour toutes les sortes qui y figurent.
  \begin{align}
  \eqlabel{supp}
    \supp{A} &= \{ p \in \Proc \mid \sorte{p} \in \sorte{A} \wedge
      p = \prem{\sort{p}}{\delta} \} \enspace, \\
  \eqlabel{fin}
    \fin{A} &= \{ p \in \Proc \mid \sorte{p} \in \sorte{A} \wedge
      p = \der{\sort{p}}{\delta} \} \enspace.
  \end{align}
\end{definition}

La \defref{substate} établit la notion de sous-état sur un ensemble de sortes,
\cad un ensemble de processus qui sont deux à deux de sortes différentes,
ce qui permet de ne considérer qu'une partie d'un état complet.
Nous notons $\PHsubl$ l'ensemble de tous les sous-états et nous constatons qu'un
état est \textit{a fortiori} un sous-état : $\PHl \subset \PHsubl$.
Nous notons de plus $\PHsublset$ l'ensemble des sous-états désordonnés,
c'est-à-dire dont l'ordre entre les sortes a été oublié.
Le recouvrement d'un état $s$ par un processus $a_i$ est formalisé à la \defref{recouvrement}
par un état identique à $s$, sauf pour le processus de $a$ qui a été remplacé par $a_i$,
ce qui permettra de définir la dynamique des Frappes de Processus %avec $k$ classes de priorités
à la \defref{play}.
La définition de recouvrement est aussi étendue à un sous-état désordonné,
autrement dit, à un ensemble de processus contenant au plus un processus par sorte.

\begin{definition}[Sous-états ($\PHsublize{\PHl}$)]
\deflabel{substate}
  Si $S \subset \PHs$ est un ensemble de sortes, un sous-état sur $S$ est un élément de :
  $\PHsubl[\PHl]_S \DEF \bigtimes{a \in S} \PHl_a$.
  L'ensemble de tous les sous-états est noté :
  $\PHsubl[\PHl] \DEF \bigcup_{S \in\powerset(\PHs)} \PHsubl[\PHl]_S$.
  
  \noindent
  De plus, si $\mysigma \in \PHsubl[\PHl]$ et $s \in \PHl$, on note alors :
  \[\mysigma \subseteq s \EQDEF \forall a_i \in \Proc, a_i \in \mysigma \Rightarrow a_i \in s
    \enspace.\]
  
  \noindent
  Enfin, si $S \subset \PHs$, on note :
  $\PHsublset_S = \{ \toset{ps} \subset \Proc \mid ps \in \PHsubl_S \}$
  et
  $\PHsublset = \{ \toset{ps} \subset \Proc \mid ps \in \PHsubl \}$.
\end{definition}
%
\begin{definition}[Recouvrement ($\recouvre : \PHl \times \PHproc \rightarrow \PHl$)]
\deflabel{recouvrement}
  Étant donné un état $s \in \PHl$ et un processus $a_i \in \PHproc$,
  $(s \recouvre a_i)$ est l'état défini par :
  $\PHget{(s \recouvre a_i)}{a} = a_i \wedge
    \forall b \neq a, \PHget{(s \recouvre a_i)}{b} = \PHget{s}{b}$.
  On étend de plus cette définition à un ensemble de processus
  par le recouvrement de l'état par chaque processus,
  à condition que les processus de l'ensemble soient tous de sortes différentes :
  $\forall ps \in \PHsublset, s \recouvre ps = s \underset{a_i \in ps}{\recouvre} a_i$.
\end{definition}

Une propriété de jouabilité telle que décrite à la \defref{ppl}
est équivalente à une formule booléenne dont les atomes sont des processus dans $\Proc$.
Le langage des propriétés de jouabilité permet de décrire la présence d'une configuration
de processus actifs dans un état donné.
Il permet notamment de décrire en termes formels la jouabilité d'une action,
ce qui est immédiatement mis en pratique dans la \defref{fopph}.

\begin{definition}[Propriété de jouabilité ($\F$)]
  \label{def:ppl}
  Une \emph{propriété de jouabilité} est un élément du langage $\F$ défini \todo{inductivement ?} par :
  \begin{itemize}
    \item $\top$ et $\bot$ appartiennent à $\F$ ;
    \item si $a \in \PHs$ et $a_i \in \PHl_a$, alors $a_i$ appartient à $\F$
      et est appelé un \emph{atome} ;
    \item si $P \in \F$ et $Q \in \F$,
      alors $\neg P$, $P \wedge Q$ et $P \vee Q$ appartiennent à $\F$.
  \end{itemize}
%
  Si $P \in \F$ est une propriété de jouabilité et $\mysigma \in \PHsubl$ est un sous-état,
  on note $\Feval{P}{\mysigma}$ l'\emph{évaluation} de $P$ dans $\mysigma$:
  \begin{itemize}
    \item si $P = a_i \in \PHl_a$ est un atome, avec $a \in \PHs$,
      alors $\Feval{a_i}{\mysigma}$ est vraie si et seulement si $a_i \in \mysigma$ ;
    \item si $P$ n'est pas un atome, alors $\Feval{P}{\mysigma}$ est vraie si et seulement si
      on peut l'évaluer récursivement comme vraie en utilisant la sémantique habituelle des
      opérateurs $\neg$, $\wedge$ et $\vee$ et des constantes $\top$ et $\bot$.
  \end{itemize}
%
  Une fonction $\Fopsymbol : \PHh \rightarrow \F$ associant à toute action une propriété de jouabilité
  est appelée un \emph{opérateur de jouabilité}.
\end{definition}

Étant donné que ce langage n'utilise que des opérateur logiques classiques,
les propriétés de la logique booléenne sont applicables aux propriétés de jouabilité,
à savoir celles concernant la distributivité, l'associativité et la commutativité,
ainsi que les lois de De Morgan concernant la négation.

Il en résulte notamment la propriété suivante, permettant d'évaluer la négation d'un atome,
et qui dérive naturellement du fait que si un processus n'est pas actif dans un état donné,
cela signifie alors qu'un autre processus de la même sorte l'est :
\[\forall a \in \PHs, \forall a_i \in \PHl_a, \forall \mysigma \in \PHsubl,
  \Feval{\neg a_i}{\mysigma} \Leftrightarrow
  \Feval{\bigvee_{\substack{a_j \in \PHl_a\\a_j \neq a_i}} a_j}{\mysigma}\]

Enfin, on note dans la suite :
\[\forall A \in \PHsublset, \Fconj{A} \equiv \bigwedge_{p \in A} p \enspace.\]

\todo{Gluer}

\begin{definition}[Opérateur de jouabilité ($\Fopsymbol : \PHh \rightarrow \F$)]
\deflabel{fopph}
  L'opérateur de jouabilité des Frappes de Processus est défini par :
  \[\forall h \in \PHh, \Fop{h} \equiv \hitter{h} \wedge \target{h} \enspace.\]
\end{definition}

\begin{definition}[Dynamique des Frappes de Processus ($\PHtrans$)]
\deflabel{play}
  Une action $h \in \PHh$ est dite \emph{jouable}
  dans l'état $s \in \PHl$ si et seulement si :
  $\Feval{\Fop{h}}{s}$.
%  $\target{h} \in s \wedge \Feval{\Fop{h}}{s}$.
  Dans ce cas, $(s \PHplay h)$ est l'état résultant du jeu de l'action $h$ dans $s$,
  et on le définit par : $(s \PHplay h) = s \recouvre \bounce{h}$.
  De plus, on note alors : $s \PHtrans (s \PHplay h)$.

  Si $s \in \PHl$, un \emph{scénario} $\delta$ dans $s$
  est une séquence d'actions de $\PHh$ qui peuvent être jouées successivement dans $s$.
  L'ensemble de tous les scénarios dans $s$ est noté $\Sce(s)$.
\end{definition}

\begin{example}
  La séquence d'actions suivantes est un scénario dans l'état \TODO des Frappes de Processus
  de la \figref{metazoan-ph-nocoop} :
  \TODO
\end{example}



\subsection{Sortes coopératives}
\seclabel{sc}

\TODO


\todo{Figure d'exemple de sorte coopérative}

\begin{example}
\exlabel{metazoan-ph}
  Le modèle de Frappes de Processus de la \figref{metazoan-ph-nocoop}
  représentant le mécanisme de segmentation métazoaire évoqué à la page
  \expageref{metazoan-ph-nocoop},
  la production de pigment devrait uniquement être possible à la condition suivante :
  «~$f$ est actif et $c$ n'est pas actif~».
  Or dans l'état courant du modèle,
  la désactivation du gène $f$ n'empêche pas la production de pigment,
  car depuis tout état contenant $f_0$, il est toujours possible d'activer $a$
  à l'aide des actions $\PHfrappe{f_0}{c_1}{c_0}$ et $\PHfrappe{c_0}{a_0}{a_1}$.
  
  Afin de pallier partiellement ce défaut, il est possible d'ajouter une sorte coopérative $fc$,
  comme à la \figref{metazoan-ph},
  afin de détecter la présence de $f_1$ et $c_0$.
  Les deux actions $\PHfrappe{c_0}{a_0}{a_1}$ et $\PHfrappe{c_0}{a_0}{a_1}$
  sont alors remplacées par une action $\PHfrappe{fc_{10}}{a_0}{a_1}$
  afin d'avoir une véritable coopération entre ces deux processus pour activer $a$.
  
  \begin{figure}[ht]
  \begin{center}
  \begin{tikzpicture}
    \exmetazoan
    
    \TState{f_1, a_0, c_0, fc_2}
  \end{tikzpicture}
  \caption{\figlabel{metazoan-ph}%
    Amélioration du modèle de Frappes de Processus de la \figref{metazoan-ph-nocoop}
    à l'aide de la sorte coopérative $fc$.
    Les processus de cette sorte représentent les différents sous-états formés par les
    deux sortes $f$ et $c$.
    Ainsi, $fc_{00}$ représente le fait que $f_0$ et $c_0$ sont actifs, etc.
    Les actions permettant la mise à jour de cette sorte coopérative n'ont pas
    été représentée explicitement mais sont symbolisées par les deux flèches
    en zigzag provenant de $f$ et $c$.
  }
  \end{center}
  \end{figure}
\end{example}

\todo{Explications sur l'imperfection des sortes coopératives}

\begin{example}
\exlabel{metazoan-ph-decalagetemporel}
  Malgré l'ajout d'une sorte coopérative $fc$ dans le modèle
  de la \figref{metazoan-ph-nocoop},
  il faut noter que le comportement désiré n'est pas exactement atteint.
  En effet, l'ajout de cette sorte coopérative devait permettre d'éviter toute activation de $a$
  lorsque $f$ devenait inactif, en permettant par exemple de jouer ce type de scénario
  depuis l'état initial $\etat{a_0, c_0, f_1, fc_{10}}$ :
    \[\PHfrappe{f_1}{f_1}{f_0} \cons \PHfrappe{f_0}{fc_{10}}{fc_{00}}\]
  après lequel il n'est plus possible d'atteindre un état où $a_1$ est actif.
  
  Cependant, il se trouve qu'il existe encore un cas particulier où $a$ peut être activé
  malgré la présence de $f_0$.
  Ce cas particulier relève du comportement mis en valeur \todo{dans les paragraphes ci-dessus},
  où une action a pour frappeur un processus de sorte coopératif qui ne devrait pas être
  actif si celle-ci avait été mise à jour.
  Il s'observe par exemple en jouant le scénario suivant depuis l'état initial
  $\etat{a_0, c_0, f_1, fc_{10}}$ :
    \[\PHfrappe{f_1}{f_1}{f_0} \cons \PHfrappe{fc_{10}}{a_0}{a_1} \enspace,\]
  ce qui est possible parce que la sorte $fc$ n'a pas été mise à jour avant le jeu
  de l'action $\PHfrappe{fc_{10}}{a_0}{a_1}$.
\end{example}

\begin{comment}
\subsection{Modelling cooperation}
\label{ssec:cooperation}

Cooperation between processes to make another process bounce can be expressed in PH by building a \emph{cooperative sort}, as described in \cite{PMR10-TCSB}.
\pref{fig:ph-livelock} shows an example of cooperation between processes $a_1$ and $b_1$ to make $c_0$ bounce to $c_1$:
a cooperative sort $ab$ is defined with 4 processes (one for each sub-state of the presence of processes $a_1$ and $b_1$).
For the sake of clarity, the processes of $ab$ are indexed using the sub-state they represent.
Hence, $ab_{10}$ represents the sub-state $\PHstate{a_1,b_0}$, and so on.
Each process of sort $a$ and $b$ hit $ab$ to make it bounce to the process reflecting the status of the sorts $a$ and $b$
(\eg $\PHfrappe{a_1}{ab_{00}}{ab_{10}}$ and $\PHfrappe{a_1}{ab_{01}}{ab_{11}}$).
Then, to represent the cooperation between $a_1$ and $b_1$, the process $ab_{11}$ hits $c_0$ to make it bounce to $c_1$ instead of independent hits from $a_1$ and $b_1$.

We note that cooperative sorts are standard PH sorts and do not involve any
special treatment regarding the semantics of related actions.
Furthermore, it is possible to “factorise” cooperative sorts in order to decrease the number of processes created within each cooperative sort.
For example, if three processes $x_1$, $y_1$ and $z_1$ cooperate,
it is preferable to create a cooperative sort $xy$ with 4 processes to state the presence of $x_1$ and $y_1$
and a second cooperative sort $xyz$ with 4 processes to state the presence of $xy_{11}$ and $z_1$,
rather than a unique cooperative sort with 8 processes stating the presence of $x_1$, $y_1$ and $z_1$.
This “factorisation” allows to prevent the combinatorial explosion of the number of processes in cooperative sorts,
especially for cooperations between more than three processes.
It may have computational consequences as the static analysis method developed in~\pref{sec:sa} does not suffer from the number of sorts but from the number of processes in each sort.

The construction of cooperation in PH allows to encode any Boolean function between cooperating processes \cite{PMR10-TCSB}.
Due to the introduction of priorities into the PH framework,
it is possible to build cooperations with no temporal shift by defining actions updating the cooperative sorts with the highest class of priority.
This allows to gain the same expressivity in PH than in Boolean networks, as stated in \pref{sec:dn}.
The aim of this paper is to allow the static analysis of the dynamics to be handled on PH models involving such prioritised actions updating cooperative sorts.
\end{comment}



\subsection{Analyse statique}
\seclabel{ph-as-pf}

\todo{Rappels sur les résultats d'analyse statique (cf. MSCS'10)}

\todo{+ Points fixes}



\subsection{Analyse stochastique}
\seclabel{ph-stocha}

\todo{Rappels rapides ?}

\newcommand{\stochainf}{{\small $\infty$}}
\newcommand{\stochaa}{{\footnotesize $\spadesuit$}}
\newcommand{\stochab}{{\footnotesize $\clubsuit$}}
\newcommand{\stochac}{{\footnotesize $\blacktriangledown$}}

\begin{example}
\exlabel{metazoan-stocha-params}
  Afin d'enrichir les Frappes de Processus standards décrites par la \vfigref{metazoan-ph},
  nous définissons les fenêtres de tir suivantes :
  %les paramètres stochastiques suivants :
  \begin{itemize}
    \item $f_1 = [0; 0]$ (\stochainf),
    \item $f_2 = [5; 15]$ (\stochaa),
    \item $f_3 = [20; 22]$ (\stochab),
    \item $f_4 = [50; 60]$ (\stochac).
  \end{itemize}
  Ces paramètres sont représentés sur des lignes temporelles à la \figref{metazoan-stocha-params}.

  \begin{figure}[ht]
  \begin{center}
  \scalebox{1.5}{
  \begin{tikzpicture}[plot]
    \node at (0,2.3) {\stochainf};
    \draw[axe] (0,2) -- (7,2) node[right] {$t$};
    \draw (0,1.9) -- (0,2.1);
    \draw[interval,blue!50] (-0.1,2) -- (0.1,2);

    \node at (1,1.3) {\stochaa};
    \draw[axe] (0,1) -- (7,1) node[right] {$t$};
    \draw (0,0.9) -- (0,1.1);
    \draw[interval] (0.5,1) -- (1.5,1);

    \node at (2.1,0.3) {\stochab};
    \draw[axe] (0,0) -- (7,0) node[right] {$t$};
    \draw (0,0.1) -- (0,-0.1);
    \draw[interval,orange] (2,0) -- (2.2,0);

    \node at (5.5,-0.7) {\stochac};
    \draw[axe] (0,-1) -- (7,-1) node[right] {$t$};
    \draw (0,0.1) -- (0,-0.1);
    \draw[interval,brown] (5,-1) -- (6,-1);
  \end{tikzpicture}
  }
  \end{center}
  \caption{\figlabel{metazoan-stocha-params}%
    Exemples d'intervalles de tirs correspondant aux paramètres stochastiques donnés
    \vexpageref{metazoan-stocha-params}.
  }
  \end{figure}

\end{example}
