% Inférence du modèle de Thomas

\section{Inférence du modèle de Thomas}
\seclabel{trad-thomas}

\TODO

\todo{Nous notons pour finir que la complexité de cette méthode est exponentielle dans le nombre
de régulateurs de chaque composant, et linéaire dans le nombre total de composants.
\footnote{Ce travail a été réalisé dans le cadre d'une collaboration avec Katsumi Inoue.
Cette collaboration a débuté par un stage doctoral de trois mois dans l'Inoue Laboratory,
au National Institute of Informatics (Tokyo, Japon).}}

\todo{Citer FPIMR-10}

Dans toute cette section, nous considérons un modèle de Frappes de Processus canoniques
$\PH = (\PHs; \PHl; (\PHh^{(1)}; \PHh^{(2)}))$.

\subsection{Inférence du graphe des interactions}
\seclabel{trad-thomas-gi}

Un graphe des interactions (\vdefref{thomas-gi}) est une représentation abstraite des
influences directes, positives ou négatives, entre les composants d'un système.
Comme discuté à la \vsecref{thomas-analyse}, le graphe des interactions permet
de caractériser efficacement les propriétés dynamiques globales du système,
à l'aide notamment de résultats comme les conjectures de Thomas,
qui apportent des résultats sur la présence d'oscillations ou d'états stables multiples.

Dans le cas d'un processus de modélisation d'un réseau de régulation biologique, le modèle
de Thomas est le point de départ e la spécification du modèle.
Cependant, il est courant que le graphe des interactions initialement conçu contienne des
influences qui n'ont pas d'impact sur la dynamique.
La méthode que nous proposons dans la suite s'appuie directement sur la dynamique d'un modèle
de Frappes de Processus canoniques, ce qui produit des graphes des interactions minimaux,
et permet d'affiner les conclusions de telles méthodes d'analyse statique.

L'intuition de cette inférence est que seuls les composants (les sortes dans $\components$)
figureront dans le graphe des interactions ;
les sortes coopératives (dans $\cs$) sont uniquement étudiées pour comprendre les actions
«~indirectes~» entre composants.



\subsubsection{Frappes de Processus bien-formées}

Nous notons que dans cette section, les indices des processus de composants
possèdent une importance particulière,
notamment pour contraindre le fait que la dynamique doit être unitaire (\crref{unitaire}).
Autrement dit, si on suppose que ces indices représentent des niveaux d'expression discrets
ordonnés,
par exemple si $b_0$, $b_1$ et $b_2$ représentent le fait que le composant $b$
est présent respectivement en faible, moyenne et forte concentration,
alors une action de la forme $\PHfrappe{a_1}{b_0}{b_2}$ n'est pas autorisée ;
en revanche, deux actions $\PHfrappe{a_1}{b_0}{b_1}$ et $\PHfrappe{a_1}{b_1}{b_2}$ le sont.
Naturellement, toute autre relations d'ordre entre les indices est admissible,
à condition qu'une contrainte d'unicité similaire puisse être définie.

\begin{equation}
\components = \{a \in \PHs \mid \nexists \PHfrappe{b_i}{a_j}{a_k} \in \PHa, |j - k| > 1\} \\
\eqlabel{PH-components}
\end{equation}

\begin{critere}[Dynamique unitaire]
\crlabel{unitaire}
  Toutes les actions secondaires de $\PH$ ne font pas de bond
  à plus d'un processus d'écart :
  $\forall \PHfrappe{a_i}{b_j}{b_k} \in \PHh^{(2)}, \card{j - k} = 1$
\end{critere}

\begin{example}
  Nous nous intéresserons dans la suite à l'inférence du graphe des interactions des deux
  modèles de Frappes de Processus canoniques représentés
  aux \figref{infer-ex-ph-nocoop,infer-ex-ph}.
  Ceux-ci possèdent tous deux une dynamique unitaire selon le \crref{unitaire},
  et sont donc compatibles
  avec l'inférence du graphe des interactions proposée à la section suivante.
  Il est à noter notamment que les actions de mise à jour de la sorte coopérative
  du modèle de la \figref{infer-ex-ph} ne sont pas unitaires, mais ces actions ne sont pas prises
  en compte par ce critère.
\end{example}

\begin{remark}
  Le \crref{unitaire} est naturellement vérifié pour tout modèle booléen,
  c'est-à-dire tel que : $\forall a \in \components, \card{\PHl_a} = 2$.
\end{remark}

\begin{remark}
  Il est possible de ne pas prendre en compte le \crref{unitaire},
  à condition de s'affranchir de l'aspect unitaire de la dynamique du modèle de Thomas.
  Les résultats de cette section restent alors théoriquement applicables.
\end{remark}

Nous considérons dans la suite que les Frappes de Processus canoniques $\PH$ respectent
le \crref{unitaire}.



\subsection{Inférence des interactions}
\seclabel{infer-gi}


L'inférence de cette section est directement inspirée des travaux de \citeasnoun{Richard10},
qui déduit les influences d'un graphe des interactions en fonction des évolutions des différents
composants, selon l'état de ses régulateurs.

\newcommand{\myupsilon}{\upsilon}

Pour tout composant $a$,
les \emph{prédécesseurs} de $a$, notés $\pred(a)$,
sont toutes les sortes ayant au moins une action frappant $a$.
Les \emph{régulateurs} de $a$, en revanche, notés $\reg(a)$, sont tous les composants
qui influent sur $a$, soit directement, soit à travers une sorte coopérative.
Il est à noter que les régulateurs définis de cette manière seront potentiellement
des régulateurs de $a$ dans le modèle de Thomas inféré,
tels que définis \vpageref{regulateurs},
ce qui explique pourquoi ces deux définitions sont proches.

\begin{align*}
  \forall a \in \components, \pred(a) &\DEF \{ b \in \PHs \mid
    \exists h \in \PHh, \sorte{\frappeur{h}} = b \wedge
    \sorte{\cible{h}} = a \} \\
  \forall a \in \components, \reg(a) &\DEF \{ \compin(b) \mid
    b \in \pred(a) \}
\end{align*}
Où $\compin(b)$ fait référence aux composants qui régulent la sorte coopérative $b$,
autrement dit aux sortes que $b$ représente
(cf.~\vdefref{comp}).

L'étude des influences d'un composant $b$ régulant un autre composant $a$ nécessite d'étudier
le groupe de régulateurs de $b$ qui vont influencer conjointement $a$.
Ces groupes de régulateurs sont aisément déterminés en observant les sortes coopératives.
Nous proposons ici de définir les groupes de régulateurs comme étant les composants connexes
d'un graphe reliant tous les régulateurs de $a$ qui sont représentés par une même sorte
coopérative :
\[
  \forall a \in \components,
  X(a) \DEF \mathcal{C} \big( (\reg(a),
  \{ \{b,c\} \subset \compin(\myupsilon) \mid
  \myupsilon \in \pred(a) \cap \cs \}) \big)
\]
Où $\mathcal{C}(G)$ représente l'ensemble des composantes connexes du graphe non orienté $G$.

Pour étudier l'influence d'un groupe de régulateurs $g$ sur un composant $a$,
nous effectuons une analyse exhaustive de toutes les configurations possibles de $g$.
Pour cela, il est nécessaire de définir un sous-état $\sigma$ sur les sortes de $g$,
et et de compléter ce sous-état par les processus de sorte coopérative
qui représentent l'état des composants dans $g$.
Nous définissons pour cela l'ensemble $\allFocals{a}{g}{\sigma}$
qui contient l'état des sortes de $g$, celui de $a$, et celui de toutes les sortes
coopératives frappant $a$.

%allFocals
\begin{align*}
  &\forall a \in \components, \forall g \in X(a), \forall \sigma \in \PHsubl_{g \cup \{ a \}}, \\
  & \quad
  \allFocals{a}{g}{\sigma} = \{ \PHget{\sigma}{b} \mid b \in \pred(a) \cap \components \}
  \cup \{ \pfp_\sigma(b) \mid b \in \pred(a) \cap \cs \}
\end{align*}
Avec :
\[
  \pfp_\sigma(b) = \pfp_{s \recouvre \sigma}(b)
\]
où le choix de $s \in \PHl$ est indifférent d'après le point (\ref{csss}) de la \vdefref{cs}.

Enfin, il est possible d'étudier localement la dynamique de $a$ en fonction du sous-état
$\sigma$ d'un groupe de régulateurs $g$ donné ;
cette dynamique locale se concentre donc uniquement sur les actions frappant $a$.
En effet, en faisant varier l'un des composants $b \in g$ et en observant le résultat
sur l'évolution de $a$ (tendance à l'augmentation ou à la diminution de son niveau d'expression),
il est possible d'en déduire l'influence locale de $b$ sur $a$ pour un niveau d'expression
de $b$ donné.
Pour cela, nous appelons $\irB_a(\sigma)$ l'ensemble des processus vers lesquels $a$ peut évoluer
depuis le sous-état $\sigma$ ;
naturellement, si aucune action ne frappe $a$ dans $\sigma$,
alors $\irB_a(\sigma) = \PHget{\sigma}{a}$.

\begin{align*}
  &\forall g \in X(a), \forall \sigma \in \PHsubl_{g \cup \{ a \}},
  \irB_a(\sigma) \DEF 
  \begin{cases}
    \irF_a(\sigma)
      & \text{ si } \irF_a(\sigma) \neq \emptyset\\
    \{ \PHget{\sigma}{a} \}
      & \text{ si } \irF_a(\sigma) = \emptyset
  \end{cases}\\
  &\text{où : } \irF_a(\sigma) \DEF \{ a_k \in \PHl_a \mid
    \exists b \in \PHs, \exists \PHfrappe{b_i}{a_j}{a_k} \in \PHa,
  \{ b_i, a_j \} \subset \allFocals{a}{g}{\sigma} \}\\
\end{align*}


La \propref{inference-edges} détaille l'inférence de toutes les influences locales existant
entre les composants, c'est-à-dire celles qui se produisent pour un seuil donné $t$.
L'idée principale derrière cette inférence est la suivante :
s'il existe une une influence
positive (\resp négative) d'un composant $b$ sur un autre composant $a$,
alors augmenter le niveau d'expression de $b$
va potentiellement faire faire augmenter (\resp diminuer) le niveau d'expression de $a$,
au moins dans certaines configurations (\eqref{edges-inference}).
Ainsi, ces influences locales se séparent en influences positives et négatives,
ce qui représente de potentiels arcs dans le graphe des interactions final.
De plus, l'étude des influences sur les groupes de régulateurs d'un composant $a$
permet aussi d'étudier les auto-influences de $a$
(\eqref{edges-inference-auto})
ce qui permettra potentiellement d'inférer des auto-arcs.
Finalement, il est nécessaire d'étudier le cas particulier où $a$ ne possède pas de régulateurs
(\eqref{edges-inference-noreg}).
Nous notons que cette méthode ignore naturellement tous les cas où il n'est pas possible
de distinguer une influence d'un composant sur un autre.

\begin{proposition}[Inférence des influences]
\proplabel{inference-edges}
  Nous définissons l'ensemble $\hat{E}_+$ (\resp $\hat{E}_-$)
  des \emph{influences locales positives} (\resp \emph{négatives})
  pour tout composant $a \in \components$ par :
  % Arcs a -> b, a ≠ b
  \begin{align}
    \begin{split}\eqlabel{edges-inference}
      \forall b \in \reg(a), \forall s \in \{ +, - \}, \\
      b \xrightarrow{t+1} a \in \hat{E}_s \Longleftrightarrow\ & \exists g \in X(a), b \in g,
      \exists \sigma \in \PHsubl_{g \cup \{ a \}}, \\
        &\qquad \{ b_t, b_{t+1} \} \subset \PHl_b \wedge b_t \in \sigma,\\
        &\qquad \exists a_j \in \irB_a(\sigma), \exists a_k \in \irB_a(\sigma\{b_{t+1}\}), \\
        &\qquad s = \f{signe}(k - j)
    \end{split}
    \end{align}
    % Auto-arcs depuis les groupes de régulateurs
    \begin{align}
    \begin{split}\eqlabel{edges-inference-auto}
      \forall s \in \{ +, - \}, \quad\qquad\qquad \\
      a \xrightarrow{t+1} a \in \hat{E}_s \Longleftrightarrow\ & \exists g \in X(a),
      \exists \sigma \in \PHsubl_{g \cup \{ a \}}, \\
        &\qquad \{ a_t, a_{t+1} \} \subset \PHl_a \wedge a_t \in \sigma,\\
        &\qquad \exists a_j \in \irB_a(\sigma), \exists a_k \in \irB_a(\sigma\{a_{t+1}\}), \\
        &\qquad s = \f{signe}(k - j)
    \end{split}
    \end{align}
    % Auto-arcs des composants sans prédécesseurs
    \begin{align}
    \begin{split}\eqlabel{edges-inference-noreg}
      \forall s \in \{ +, - \}, \quad\qquad\qquad \\
      a \xrightarrow{t+1} a \in \hat{E}_s \Longleftrightarrow\ & \reg(a) = \emptyset \wedge
        \{ a_t, a_{t+1} \} \subset \PHl_a, \\
        &\qquad \exists a_j \in \irB_a(\etat{a_t}), \exists a_k \in \irB_a(\etat{a_{t+1}}), \\
        &\qquad s = \f{signe}(k - j)
    \end{split}
  \end{align}
  où : $\f{signe}(x) = \begin{cases}
    + & \text{ si $x > 0$} \\
    - & \text{ si $x < 0$} \\
    0 & \text{ if $x = 0$}
  \end{cases}$
\end{proposition}

Nous sommes alors en mesure d'inférer les arcs du graphe des interactions final,
à partir de ces ensembles d'influences locales positives et négatives.
En effet, nous pouvons inférer une influence (globale) positive ou négative
d'un composant vers un autre
s'il n'existe que des influences locales correspondantes du même signe.
Une influence non-signée est inférée si, à l'inverse, il existe au moins deux influences
locales correspondantes de signes différents.
Enfin, le seuil de chaque influence (quel que soit son signe)
est égal au seuil minimum pour lequel une influence locale a été trouvée.
Nous formalisons cette inférence dans la \propref{inference-gi}.

\begin{proposition}[Inférence du graphe des interactions]
\proplabel{inference-gi}
  Nous inférons $\GI = (\components; E)$ à l'aide de la \propref{inference-edges} comme suit :
  \begin{align*}
    E_+ &= \{ \arc{a}{+}{t}{b} \mid \nexists a \xrightarrow{t'} b \in \hat{E}_-
      \wedge t = \min \{ r \mid a \xrightarrow{r} b \in \hat{E}_+ \}\} \\
    E_- &= \{ \arc{a}{-}{t}{b} \mid \nexists a \xrightarrow{t'} b \in \hat{E}_+
      \wedge t = \min \{ r \mid a \xrightarrow{r} b \in \hat{E}_- \}\} \\
    E_\uns &= \{ \arc{a}{\uns}{t}{b} \mid \exists a \xrightarrow{t'} b \in \hat{E}_+ \wedge
      \exists a \xrightarrow{t''} b \in \hat{E}_- \\
      & \qquad\qquad\qquad \wedge t = \min \{ r \mid
      a \xrightarrow{r} b \in \hat{E}_- \cup \hat{E}_+ \} \}
  \end{align*}
\end{proposition}




\begin{figure}[htp]
\centering
\scalebox{1.3}{
\begin{tikzpicture}
  \TSort{(0,0)}{a}{3}{r}
  \TSort{(-3,0.5)}{b}{2}{l}
  \TSort{(3,0.5)}{c}{2}{r}

  \THit{b_1}{}{a_0}{.west}{a_1}
  \THit{b_1}{}{a_1}{.north west}{a_2}
  \THit{b_0}{}{a_2}{.west}{a_1}
  \THit{b_0}{}{a_1}{.west}{a_0}

  \path[bounce, bend left=60]
  \TBounce{a_1}{}{a_2}{.south west}
  \TBounce{a_0}{}{a_1}{.south west}
  ;
  \path[bounce, bend right=60]
  \TBounce{a_2}{in=-140}{a_1}{.north}
  \TBounce{a_1}{}{a_0}{.north west}
  ;

  \THit{c_1}{}{a_0}{.east}{a_1}
  \THit{c_1}{}{a_1}{.north east}{a_2}
  \THit{c_0}{}{a_2}{.east}{a_1}
  \THit{c_0}{}{a_1}{.east}{a_0}

  \path[bounce, bend right=60]
  \TBounce{a_1}{}{a_2}{.south east}
  \TBounce{a_0}{}{a_1}{.south east}
  ;
  \path[bounce, bend left=60]
  \TBounce{a_2}{in=150}{a_1}{.north}
  \TBounce{a_1}{}{a_0}{.north east}
  ;

  \THit{a_2}{bend right}{b_1}{.north east}{b_0}
  \path[bounce, bend left=80]
  \TBounce{b_1}{out=100,in=140}{b_0}{.north}
  ;
\end{tikzpicture}
}
\caption{\figlabel{infer-ex-ph-nocoop}%
  Exemple de Frappes de Processus canoniques avec trois composants : $a$, $b$ et $c$.
  Ce modèle ne comporte aucune sorte coopérative.
  La dynamique de ce modèle est unitaire car elle respecte bien le \vcrref{unitaire}.
  L'inférence du graphe des interactions peut donc être effectuée sur ce modèle.
}
\end{figure}



\begin{figure}[htp]
\centering
\scalebox{1.3}{
\begin{tikzpicture}
  \path[use as bounding box] (-4,-1.9) rectangle (4.5,3.9);

  \TSort{(0,0)}{a}{3}{l}
  \TSort{(3, 3)}{b}{2}{t}
  \TSort{(3,-1)}{c}{2}{b}

  \TSetTick{bc}{0}{00}
  \TSetTick{bc}{1}{01}
  \TSetTick{bc}{2}{10}
  \TSetTick{bc}{3}{11}
  % \TSetSortLbcel{bc}{$\neg a\wedge b$}
  \TSort{(-3,-0.5)}{bc}{4}{l}

  \THit{bc_3}{}{a_1}{.north west}{a_2}
  \THit{bc_0}{}{a_1}{.south west}{a_0}
  \path[bounce]
  \TBounce{a_1}{bend left}{a_2}{.south west}
  \TBounce{a_1}{bend right}{a_0}{.north west}
  ;

  \THit{b_0}{}{a_2}{.east}{a_1}
  \THit{b_1}{}{a_0}{.north east}{a_1}
  \path[bounce]
  \TBounce{a_2}{bend left}{a_1}{.north east}
  \TBounce{a_0}{bend right=20}{a_1}{.south}
  ;

  \THit{c_0}{bend right}{a_2}{.south east}{a_1}
  \THit{c_1}{bend right}{a_0}{.east}{a_1}
  \path[bounce]
  \TBounce{a_2}{bend left=20}{a_1}{.north}
  \TBounce{a_0}{bend right=30}{a_1}{.south east}
  ;

  \path[]
    (1.9,-1.3) edge[bend left=10,coopupdate] (-2.2,-0.7)
    (1.9, 3.3) edge[bend right=10,coopupdate] (-2.2,3)
  ;

  \THit{a_2}{bend left,out=40,in=80}{b_1}{.north west}{b_0}
  \path[bounce, bend right]
  \TBounce{b_1}{}{b_0}{.east}
  ;
\end{tikzpicture}
}
\caption{\figlabel{infer-ex-ph}%
  Raffinement du modèle de Frappes de Processus canoniques de la \figref{infer-ex-ph-nocoop}
  à l'aide d'une sorte coopérative $bc$ :
  les deux actions $\PHfrappe{b_1}{a_1}{a_2}$ et $\PHfrappe{c_1}{a_1}{a_2}$
  sont ainsi remplacées par une action $\PHfrappe{bc_{11}}{a_1}{a_2}$ ;
  de même, les actions $\PHfrappe{b_0}{a_1}{a_0}$ et $\PHfrappe{c_1}{a_1}{a_0}$
  sont remplacées par $\PHfrappe{bc_{00}}{a_1}{a_0}$.
  Ce modèle possède aussi une dynamique unitaire d'après le \crref{unitaire}.
}
\end{figure}



\begin{example}
  L'application de l'inférence du graphe des interactions aux Frappes de Processus canoniques
  de la \figref{infer-ex-ph-nocoop} donne le graphe représenté à la \figref{infer-ig},
  contenant les arcs suivants :
  \begin{align*}
    E_+ &= \{\arcf{b}{+}{1}{a}, \arcf{c}{+}{1}{a}, \arcf{a}{+}{1}{a},
      \arcf{b}{+}{1}{b}, \arcf{c}{+}{1}{c}\} \\
    E_- &= \{\arcf{a}{-}{2}{b}\} \qquad\qquad\qquad\qquad\qquad
    E_\uns = \emptyset
  \end{align*}
  Ce graphe des interactions est proche de celui qui avait été proposé
  à la \figref{thomas}(gauche) \figpageref[vref]{thomas} bien qu'il ne soit pas équivalent,
  car chaque composant comporte une auto-action positive.
  Les auto-actions sur $b$ et $c$ sont la conséquence d'une stabilité globale
  sur plusieurs sous-états : en effet, $c$ n'évolue jamais,
  et $b$ n'évolue pas non plus lorsque $a_2$ n'est pas actif.
  L'auto-action sur $a$ est principalement causée par sa nature multi-valuée.
  
  \begin{figure}[ht]
  \centering
  \scalebox{1.2}{
  \begin{tikzpicture}[grn]
    \path[use as bounding box] (-1.3,-0.75) rectangle (3.5,1.5);
    \node[inner sep=0] (a) at (2,0) {a};
    \node[inner sep=0] (b) at (0,0) {b};
    \node[inner sep=0] (c) at (2,1.2) {c};
    \path[->]
      (b) edge[bend right] node[elabel, below=-2pt] {$+1$} (a)
      (c) edge node[elabel, right=-2pt] {$+1$} (a)
      (a) edge[bend right] node[elabel, above=-5pt] {$-2$} (b)
      (b) edge[in=-15+180, out=15+180, loop] node[elabel, left=-2pt] {+1} (b)
      (c) edge[in=15, out=-15, loop] node[elabel, right=-2pt] {+1} (c)
      (a) edge[in=15, out=-15, loop] node[elabel, right=-2pt] {+1} (a);
  \end{tikzpicture}
  }
  \caption{\figlabel{infer-ig}%
    Graphe des interactions inféré depuis les Frappes de Processus de la \figref{infer-ex-ph}.
  }
  \end{figure}
\end{example}

\begin{example}
  Le modèle raffiné de Frappes de Processus canoniques représenté à la \figref{infer-ex-ph}
  comporte une sorte coopérative $bc$ qui permet de modéliser la coopération
  de $b_1$ et $c_1$ pour faire bondir $a_1$ en $a_2$,
  ainsi que la coopération de $b_0$ et $c_0$ pour faire bondir $a_1$ en $a_0$.
  Ces deux coopérations étaient représentées dans le modèle de la \figref{infer-ex-ph-nocoop}
  par des actions indépendantes.
  Cependant, ce modèle raffiné produit le même résultat en termes de graphe des interactions,
  c'est-à-dire le graphe de la \figref{infer-ig},
  ce qui s'explique par le fait que les composants $b$ et $c$ produisent le même type
  de régulation sur $a$ dans les deux cas (avec des actions indépendantes ou à travers une sorte
  coopérative).
\end{example}

\begin{example}
  L'ajout d'une action $\PHfrappe{a_2}{b_0}{b_1}$ aux Frappes de Processus canoniques raffinées
  de la \figref{infer-ex-ph} modifie le résultat de l'inférence.
  En effet, dans ce cas deux arcs non-signés vers $b$ sont inférés en lieu et place
  des arcs signés précédents :
  \begin{align*}
    E_+ &= \{\arcf{b}{+}{1}{a}, \arcf{c}{+}{1}{a}, \arcf{a}{+}{1}{a}, \arcf{c}{+}{1}{c}\}\\
    E_- &= \emptyset \qquad\qquad\qquad\qquad
    E_\uns = \{\arcf{a}{\uns}{2}{b}, \arcf{b}{\uns}{1}{b}\}
  \end{align*}
  Cela est dû au fait que les actions $\PHfrappe{a_2}{b_1}{b_0}$ et $\PHfrappe{a_2}{b_0}{b_1}$
  introduisent des oscillations causées uniquement par le processus $a_2$,
  ce qui implique une influence locale à la fois positive et négative,
  et est impossible à représenter au sein d'un modèle de Thomas.
\end{example}








\subsection{Inférence de la paramétrisation}
\seclabel{infer-param}

Une fois obtenu le graphe des interactions inféré selon la méthode proposée à la section
précédente, il est ensuite possible d'inférer une partie des paramètres discrets
propres à un modèle de Thomas, en fonction de la dynamique des Frappes de Processus canoniques
d'origine.
Cette inférence repose à nouveau sur une exploration exhaustive des comportements possibles
du modèle en fonction de l'état des prédécesseurs de chaque composant.
Cependant, cette inférence peut être partielle si le comportement modélisé
ne peut pas être représenté à l'aide d'un modèle de Thomas.
Dans ce cas, il est possible d'inférer une partie seulement des paramètres,
puis d'énumérer toutes les modèles compatibles avec cette paramétrisation partielle,
la dynamique du modèle et certaines contraintes de modélisation sur les paramètres.

\subsection{Inférence des paramètres}
\seclabel{infer-params}

Cette sous-section présente l'inférence des paramètres discrets indépendants
à partir d'un modèle de Frappes de Processus donné.
Ces résultats sont équivalents à ceux présentés par \citeasnoun{PMR10-TCSB},
auxquels nous ajoutons la notion de \emph{Frappes de Processus bien formées
pour l'inférence des paramètres}, définie au \crref{infer-params-ok},
et qui stipule que pour toute régulation de $a$ par $b$,
tous les processus de $\levels{b}{a}$ (\resp $\ulevels{b}{a}$)
possèdent la même influence sur $a$.

\begin{critere}[Frappes de Processus bien formées pour l'inférence des paramètres]
\crlabel{infer-params-ok}
  Des Frappes de Processus canoniques sont \emph{bien formées pour l'inférence des paramètres}
  si et seulement si leur dynamique est unitaire (\crref{unitaire})
  et si le graphe des interactions $(\components; E)$ inféré par \propref{inference-gi}
  vérifie :
  \begin{align*}
    \begin{split}
      \forall a \in \components &, \forall b \in \RRBreg{a},
        \forall N \in \{ \levels{b}{a}, \ulevels{b}{a} \}, \forall i,j \in N, \\
        %\forall (i, j \in \levels{b}{a} \vee i, j \in \ulevels{b}{a}), \\
      & \forall c \in \PHs, ( (b \neq a \wedge c = a) \vee
        (\exists \myupsilon \in \pred(a), c \in \conn(\myupsilon) \wedge b \in \compin(c)), \\
%        (c \in \PHpredec{a} \setminus \components \wedge b \in \PHdirectpredec{c})), \\
      & \qquad \PHfrappe{b_i}{c_k}{c_l}\in\PHa \Leftrightarrow \PHfrappe{b_j}{c_k}{c_l}\in\PHa
    \end{split}
  \end{align*}
\end{critere}

On souhaite dans la suite inférer le paramètre discret $K_{a,\omega}$,
pour un composant $a \in \components$ et un ensemble $\omega \subset \RRBreg{a}$
de ressources donnés.
Cette inférence se base, à l'instar de l'inférence du graphe des interactions, sur une analyse
exhaustive des sous-états des régulateurs de $a$.
Pour chaque sorte $b \in \RRBreg{a}$, on définit une configuration $C^b_{a,\omega}$
(\eqref{param-config}) qui recense tous les processus qui interagissent avec $a$
dans tous les sous-états représentés par l'ensemble de ressources $\omega$.
La configuration d'une sorte coopérative $\myupsilon$ régulant $a$ est l'ensemble des processus
focaux correspondant à ces sous-états (\eqref{param-config-coop}).
Enfin, $C_{a,\omega}$ fait référence à l'union de toutes ces configurations
(\eqref{param-config-total}).

\begin{align}
\eqlabel{param-config}
  \forall b \in \components,~
  C_{a,\omega}^b & \DEF \begin{cases}
    \levels{b}{a}  & \text{si $b \in \omega$,}\\
    \ulevels{b}{a} & \text{si $b \notin \omega$,}\\
    L_b            & \text{sinon}\\
  \end{cases}
  \\
\eqlabel{param-config-coop}
  \forall \myupsilon \in \pred(a) \cap \cs,
    C_{a,\omega}^\myupsilon & \DEF \{ \pfp_{\sigma}(\myupsilon) \mid
    \sigma \in \bigtimes{b \in \compin(\myupsilon)} C_{a,\omega}^b \} \\
\eqlabel{param-config-total}
  C_{a,\omega} & \DEF \bigcup_{b \in \pred(a)} C^b_{a,\omega}
\end{align}

Pour inférer le paramètre recherché, nous calculons les \emph{processus focaux} de $a$,
qui sont les processus vers lesquels tend le niveau d'expression de $a$ en présence
de certains autres processus (\defref{focals}).
Ainsi, $\focals(a, S, T)$ donne l'ensemble des processus de $a$ accessibles
en partant de n'importe quel processus dans $S$, et à condition de ne jouer que des
actions dont le frappeur est dans $T$.
Cette notion se base sur un graphe recensant tous les bonds que peuvent faire les processus
de $a$ ;
si ce graphe est acyclique, alors l'ensemble des processus focaux est l'ensemble des processus
de $a$ qui ne sont pas frappés ---~et vers lesquels $a$ va avoir tendance à évoluer.

\begin{definition}[$\focals(a,S,T)$]
\deflabel{focals}
  L'ensemble des \emph{processus focaux} de $a \in \components$ depuis $S \subset \PHl_a$
  pour le sous-état $T \subset \Proc$ est donné par :
  \[
    \focals(a, S, T) \DEF
    \begin{cases}
      \{ a_i \in V \mid \nexists (a_i,a_j)\in E\} & \text{si $(V,E)$ est acyclique},\\
      \emptyset & \text{sinon}\\
    \end{cases}
  \]
  où $(V,E)$ est le graphe orienté suivant :
  \begin{align*}
    E & \DEF \{ (a_j; a_k) \in (\PHl_a \times \PHl_a) \mid
      \exists \PHfrappe{b_i}{a_j}{a_k} \in \PHh^{(2)}, b_i \in T \wedge a_j \in S \} \\
    V & \DEF S \cup \{ a_k \in \PHl_a \mid \exists (a_j; a_k) \in E \}
    %\eqlabel{bounce-graph}
  \end{align*}
\end{definition}

Le paramètre $K_{a,\omega}$ détermine les niveaux d'expression vers lesquels tend $a$
en présence de la configuration $C_{a,\omega}$.
Cette valeur peut être calculée à l'aide de $\focals$ qui permet justement
de retrouver les processus focaux en présence de certaines ressources.
Ainsi, on peut en conclure que $K_{a,\omega} = \focals(a,C^a_{a,\omega},C_{a,\omega})$
dans tous les cas où cette valeur est un intervalle non vide (\propref{inference-param}).

\begin{proposition}[Inférence des paramètres]
\proplabel{inference-param}
  Soient $\PH = (\PHs, \PHl, \PHh)$ des Frappes de Processus bien formées pour l'inférence des
  paramètres, $\GI = (\components, E)$ le graphe des interactions inféré pour $\PH$
  et $\omega \subset \RRBres{a}$ un ensemble de ressources de $a$.
  Si $\focals(a,C^a_{a,\omega},C_{a,\omega})$ est un intervalle non vide,
  avec $\focals(a,C^a_{a,\omega},C_{a,\omega}) = \segm{a_i}{a_j}$,
  alors $K_{a,\omega} = \segm{i}{j}$.
\end{proposition}



\begin{example}
\exlabel{infer-param-nocoop}
  Si on l'applique aux Frappes de Processus de la \figref{infer-ex-ph-nocoop},
  la méthode d'inférence des paramètres donnée dans cette section est conclusive sur la majorité
  des paramètres et donne :
  \begin{align*}
    K_{a, \emptyset} &= \segm{0}{0} &
    K_{b, \emptyset} &= \segm{0}{0} \\
    K_{a, \{a\}} &= \segm{0}{0} &
    K_{b, \{a\}} &= \segm{0}{0} \\
    K_{a, \{c\}} &= \segm{1}{1} &
    K_{b, \{b\}} &= \segm{1}{1} \\
    K_{a, \{b\}} &= \segm{1}{1} &
    K_{b, \{a,b\}} &= \segm{0}{0} \\
    K_{a, \{b,c\}} &= \segm{1}{1} &
    K_{c, \emptyset} &= \segm{0}{0} \\
    K_{a, \{a,b,c\}} &= \segm{2}{2} &
    K_{c, \{c\}} &= \segm{1}{1} \\
%     K_{a,\{a,b\}} &= \segm{1}{1} &
%     K_{a,\{a,c\}} &= \segm{1}{1}
  \end{align*}
  Seuls les paramètres $K_{a,\{a,b\}}$ et $K_{a,\{a,c\}}$ n'ont pas peu être inférés.
  Cela est la conséquence directe de l'absence de coopération explicite entre $b$ et $c$ sur $a$,
  ce qui crée des oscillations sur $a$ lorsque $b_1$ et $c_0$ ou $b_0$ et $c_1$
  sont présents simultanément.
\end{example}

\begin{example}
  Le modèle raffiné de Frappes de Processus canoniques de la \figref{infer-ex-ph}
  comporte une coopération explicite entre $b$ et $c$ à l'aide de la sorte coopérative $bc$.
  Cela permet notamment à l'inférence d'être davantage conclusive ;
  ainsi, les résultats sont les mêmes que dans l'exemple précédent,
  en dehors des deux paramètres suivants dont la valeur a pu être inférée :
  \begin{align*}
    K_{a,\{a,b\}} &= \segm{1}{1} &
    K_{a,\{a,c\}} &= \segm{1}{1}
  \end{align*}
\end{example}



\myskip

En observant la \propref{inference-param}, on constate que l'inférence
de certains paramètres peut ne pas être possible.
Cela peut être notamment dû à des coopérations mal définies entre les régulateurs d'un composant :
lorsque deux régulateurs frappent un même composant de façon indépendante, leurs actions peuvent
avoir des effets opposés, créant des oscillations dans la dynamique.
Un tel indéterminisme ne peut pas être représenté à l'aide d'un modèle de Thomas étant donné
que dans une configuration de ressources données, un composant possède un unique attracteur,
représenté par le paramètre discret correspondant,
et ne peut donc évoluer que dans une seule direction.
Il est possible de résoudre ces cas non conclusifs
(autrement dit, de supprimer ces comportements oscillants)
en raffinant le modèle à l'aide de suppressions d'actions ou
en s'assurant que les coopérations sont correctement définies à l'aide de sortes coopératives
afin d'éviter des influences opposées depuis des régulateurs concurrents.



\subsection{Énumération des paramétrisations admissibles}
\seclabel{enum-param}

Lors de la construction d'un modèle de Thomas, trouver la paramétrisation compatible avec
le comportement désiré est nécessaire pour obtenir un modèle complet.
Cependant, cette étape possède une complexité inhérente à ce type de formalisme,
car le nombre de paramètres que contient le modèle croît exponentiellement dans
la taille du graphe des interactions
(plus précisément, dans le nombre de régulations vers chaque composant).
La méthode d'inférence des paramètres présentée précédemment permet cependant d'obtenir
certaines informations sur ces paramètres en fonction de la dynamique des Frappes de Processus
canoniques étudiées.
Ces informations permettent donc de restreindre l'espace des paramétrisations possibles,
et donc d'obtenir plus facilement le modèle recherché.

En d'autres termes,
lors de l'inférence d'un modèle de Thomas selon la méthode décrite précédemment,
il arrive que certains paramètres ne puissent pas être inférés.
Le modèle obtenu est alors partiel, et correspond à un ensemble
plus ou moins large de modèles complets.
En énumérant les valeurs possibles de chaque paramètre, il est envisageable de retrouver
l'ensemble des modèles \emph{compatibles} avec ces valeurs.

\myskip

Nous délimitons tout d'abord la validité d'un paramètre (\crref{params-valide}) afin d'assurer
que toutes les transitions dans le modèle de Thomas résultant
sont permises par la dynamique des Frappes de Processus canoniques étudiées.
Cette propriété est vérifiée en s'assurant,
pour chaque configurations de ressources possibles,
de l'existence d'une frappe faisant bondir
le processus d'une sorte vers le paramètres correspondant.
Ainsi, conjointement avec le fait que les Frappes de Processus étudiées
sont bien formées pour l'inférence des paramètres,
nous assurons que pour toute transition dans le modèle de Thomas inféré,
il existe une transition équivalente dans les Frappes de Processus d'origine.
Nous remarquons par ailleurs que les paramètres inférés à l'aide de la \vpropref{inference-param}
vérifient déjà cette propriété.



\begin{critere}[Validité d'un paramètre]
\crlabel{params-valide}
  Un paramètre $K_{a,\omega}$ est \emph{valide} pour les Frappes de Processus $\PH$
  si et seulement si :
  \begin{align*}
    \forall a_i\in C^a_{a,\omega}, a_i \notin K_{a,\omega} \Longrightarrow
      (& \exists \PHfrappe{c_k}{a_i}{a_j}\in\PHa, c_k \in C^c_{a,\omega} \\
      & \wedge a_i < K_{a,\omega} \Rightarrow j > i \wedge  a_i > K_{a,\omega} \Rightarrow j <i )
  \end{align*}
\end{critere}

Nous utilisons de plus plusieurs contraintes de modélisation \citeaffixed{BernotSemBRN}{tirées de}
afin d'assurer une cohérence des paramètres avec les signes des régulations du graphe
des interactions préalablement inféré.
L'\emph{hypothèse des valeurs extrêmes} (\crref{param-enum-extreme})
stipule que les niveaux extrêmes d'un composant $a$ (c'est-à-dire $0$ et $l_a$)
doivent chacun apparaître dans au moins un paramètre.
L'\emph{hypothèse d'activité} (\crref{param-enum-activity})
stipule en outre que toutes les régulations doivent être fonctionnelles,
c'est-à-dire que pour chaque régulateur d'un composant,
il existe au moins une configuration dans laquelle la présence ou l'absence de ce régulateur
modifie le paramètre considéré.
Enfin, l'\emph{hypothèse de monotonicité} (\crref{param-enum-monotonicity})
stipule qu'ajouter un activateur (\resp inhibiteur) aux ressources d'un composant
ne peut qu'augmenter (\resp diminuer) la valeur du paramètre considéré.
La relation d'ordre $\leqsegm$ entre deux paramètres discrets s'applique à des segments
et est définie à la \vsecref{notations}.

\begin{critere}[Hypothèse des valeurs extrêmes]
\crlabel{param-enum-extreme}
  Soit $\GI = (\components, E)$ un graphe des interactions.
  Une paramétrisation $K$ sur $\GI$ satisfait l'\emph{hypothèse des valeurs extrêmes}
  si et seulement si :
  \begin{align*}
    \forall b \in \components, \RRBreg{b} \neq \emptyset \Longrightarrow
    \exists \omega \subset \RRBreg{b}, 0 \in K_{b,\omega} \wedge
    \exists \omega' \subset \RRBreg{b}, l_b \in K_{b,\omega'}
  \end{align*}
\end{critere}

\begin{critere}[Hypothèse d'activité]
\crlabel{param-enum-activity}
  Soit $\GI = (\components, E)$ un graphe des interactions.
  Une paramétrisation $K$ sur $\GI$ satisfait l'\emph{hypothèse d'activité}
  \begin{align*}
    \forall b \in \components, \forall a \in \RRBreg{b}, \exists \omega \subset \RRBreg{b},
    K_{b,\omega} \neq K_{b,\omega \cup \{ a \}}
  \end{align*}
\end{critere}

\begin{critere}[Hypothèse de monotonicité]
\crlabel{param-enum-monotonicity}
  Soit $\GI = (\components, E)$ un graphe des interactions.
  Une paramétrisation $K$ sur $\GI$ satisfait l'\emph{hypothèse de monotonicité}
  si et seulement si :
  \begin{align*}
    \forall b \in \components,
    \forall A^+ \subset \{ a \in \components \mid \arc{a}{+}{t}{b} \in E_+ \}&,
    \forall A^- \subset \{ a \in \components \mid \arc{a}{-}{t}{b} \in E_- \},\\
    K_{b,\omega \cup A^-} & \leqsegm K_{b,\omega \cup A^+}
  \end{align*}
\end{critere}



\begin{example}
%\label{ex:enum-param-runningPH-1}
  Les paramètres inférés pour le modèle de Frappes de Processus canoniques de la
  \figref{infer-ex-ph-nocoop} sont donnés \vexpageref{infer-param-nocoop}.
  Cette paramétrisation est partielle car les paramètres
  $K_{a,\{a,b\}}$ et $K_{a,\{a,c\}}$ ne peuvent pas être inférés à l'aide de la
  \propref{inference-param}.
  Il est cependant possible d'énumérer les paramétrisations compatibles avec les paramètres
  déjà trouvés et les \crrangeref{params-valide}{param-enum-monotonicity}
  présentés dans cette section.
  Cette énumération produit 9 paramétrisations différentes qui correspondent aux
  trois valeurs possibles pour chacun des paramètres qui n'ont pas pu être inférés :
  \begin{align*}
    K_{a,\{a,b\}} &\in \{ \segm{1}{1}, \segm{1}{2}, \segm{2}{2} \} \\
    K_{a,\{a,c\}} &\in \{ \segm{1}{1}, \segm{1}{2}, \segm{2}{2} \}
  \end{align*}
  Nous notons la propriété suivante pour toutes ces solutions :
  $0 \notin K_{a,\{a,b\}} \wedge 0 \notin K_{a,\{a,c\}}$.
  Cela est causé par l'hypothèse de monotonicité (\crref{param-enum-monotonicity})
  qui stipule notamment dans ce cas précis :
  \begin{align*}
    K_{a,\{b\}} \leqsegm K_{a,\{a,b\}} \wedge
    K_{a,\{c\}} \leqsegm K_{a,\{a,c\}}
  \end{align*}
  Enfin, nous notons que $\segm{1}{1}$ appartient aux valeurs possibles des deux paramètres.
  Cette énumération permet donc notamment bien de retrouver les valeurs attendues,
  inférées sur le modèle raffiné de la \figref{infer-ex-ph}.
\end{example}



\subsection{Pistes d'implémentation}
\seclabel{infer-impl}

%\newcommand{\atom}{\mathbf}
\newcommand{\atom}[1]{#1}
%\newcommand{\predicate}{\mathbf}
\newcommand{\predicate}[1]{\mathit{#1}}
\newcommand{\la}{\leftarrow}
\newcommand{\var}[1]{#1}
\newcommand{\nota}{\neg}

\newcommand{\paramlabel}{\predicate{param\_label}}
\newcommand{\paramres}{\predicate{param\_resource}}
\newcommand{\component}{\predicate{component}}
\newcommand{\componentlevels}{\predicate{component\_levels}}
\newcommand{\param}{\predicate{param}}
\newcommand{\inferedparam}{\predicate{infered\_param}}
\newcommand{\lessactive}{\predicate{less\_active}}
\newcommand{\paraminf}{\predicate{param\_inf}}

Nous abordons dans cette section quelques principes de programmation par ensemble de réponse,
aussi appelée ASP pour \textit{Answer Set Programming} \cite{Baral03,Baral10}.
Cette forme de programmation logique déclarative a été utilisée pour la résolution des inférences
du graphe des interactions et des paramètres, mais aussi pour l'énumération des paramétrisations
compatibles dans le cas où certains paramètres ne peuvent être inférés.
Nous illustrons d'ailleurs l'application d'ASP à l'énumération des paramétrisations
compatibles, car cette partie de l'implémentation présente des exemples illustratifs
intéressants, du fait notamment qu'ASP est particulièrement adapté à l'énumération
de solutions.
La résolution est effectuée à l'aide du \textit{solver} \tool{Clingo} \cite{gekakasc14b}
qui possède des heuristiques efficaces pour la résolution de nombreux
problèmes complexes.

La définition d'un problème en ASP suit généralement trois étapes principales
illustrées dans la suite :
\begin{itemize}
  \item la définition des données du problème,
  \item la création d'ensembles de réponse,
  \item le filtrage des réponses non satisfaisantes.
\end{itemize}



\subsubsection{Syntaxe des règles simples}
\seclabel{asp-simple-rules}

La définition d'un programme en ASP repose sur des règles de la forme :
\begin{align*}
  \underbrace{{\ }\atom{H}_{\ }}_{\text{tête}} \la \underbrace{\atom{A}_1, \atom{A}_2, \dots,
  \atom{A}_n, \nota \atom{B}_1, \nota \atom{B}_2, \dots, \nota \atom{B}_m}_{\text{corps}}.
\end{align*}
Dans une telle règle, le \emph{corps} et consiste en un ensemble d'atomes
(de la forme $\atom{A}_i$) et de négation d'atomes (de la forme $\nota \atom{B}_i$).
Dans le cas de \emph{règles simples}, la \emph{tête} comprend un unique atome ($\atom{H}$).
Schématiquement,
une telle règle stipule que si les atomes $\atom{A}_1, \atom{A}_2, \dots, \atom{A}_n$
sont vrais et qu'il n'est pas possible d'établir que les atomes
$\atom{B}_1, \atom{B}_2, \dots, \atom{B}_m$ sont vrais (négation par l'échec),
alors $\atom{H}$ doit être vrai.
La sémantique d'une règle sera détaillée à la \secref{impl-sem}.

Un atome est composé d'un prédicat et d'une série d'arguments (potentiellement vide),
c'est-à-dire de la forme :
\begin{align*}
  \predicate{p}(x_1, x_2, \dots, x_r)
\end{align*}
où $\predicate{p}$ est le \emph{prédicat} et $x_1, x_2, \dots, x_r$ sont les \emph{arguments}.
La valeur $r$, qui détermine le nombre d'arguments d'un atome, est appelée \emph{arité}.
Chaque argument peut être une \emph{constante}, qui représente une donnée fixe
(typiquement un nom de composant, un niveau d'expression...)
ou une \emph{variable}, qui peut prendre la valeur de n'importe quelle constante,
comme détaillé à la \secref{impl-variables}.
Dans cet exemple, nous restreignons les constantes à des valeurs numériques où à des
lettres minuscules (p.~ex. $a$, $b$, $c$, $1$, $2$, ...)
tandis que les variables seront représentées par une lettre majuscule
(p.~ex. $\var{A}$, $\var{P}$, $\var{Q}$, ...).

\begin{example}
\exlabel{impl-asp-atom}
  Considérons le modèle de Frappes de Processus canoniques de la \figref{infer-ex-ph-nocoop}.
  Dans la suite, nous utiliserons l'atome d'arité 2 suivant :
  \begin{align*}
    &\component(x, n)
  \end{align*}
  pour établir la présence d'un composant $x$ dans le modèle,
  dont le niveau d'expression maximal est $l_x = n$.
\end{example}


\subsubsection{Réponses et ensembles de réponse}
\seclabel{impl-sem}

Un programme ASP est un ensemble de règles selon la syntaxe décrite ci-dessus.
Résoudre un programme ASP signifie trouver un \emph{ensemble de réponse},
qui est un ensemble minimal d'atomes respectant toutes les règles.
Afin de définir formellement cette notion d'ensemble de réponse,
nous appelons \emph{règle positive} toute règle ne contentant pas de négation d'atome
(notée $\nota$), et \emph{programme positif} tout programme ne contenant que des
règles positives.
Une règle positive a donc la forme suivante :
\begin{align*}
  \atom{H} \la \atom{A}_1, \atom{A}_2, \dots, \atom{A}_n.
\end{align*}
Si $S$ est un ensemble d'atomes, une règle positive est dite \emph{satisfaite} par $S$
si et seulement si : $\atom{H} \in S \vee \exists i \in \segm{1}{n}, A_i \notin S$.
Étant donnée cette définition de la satisfaction d'une règle,
l'ensemble de réponse d'un programme positif $\Pi$ est
est l'ensemble minimal (unique) d'atomes $S$ satisfaisant toutes les règles de $\Pi$.

Dans le cas général, tous les programmes ne sont pas positifs.
Dans le cas d'un programme non positif $\Pi$ et d'un ensemble d'atomes $S$,
on note $\Pi^S$ la \emph{réduction} de $\Pi$ par $S$, définie en :
\begin{itemize}
  \item supprimant toutes les règles possédant une négation d'atome $\nota \atom{B}_i$
    dans leur corps telle que $\atom{B}_i \in S$,
  \item supprimant toutes les négations d'atomes dans le corps des règles restantes.
\end{itemize}
L'ensemble d'atomes $S$ est alors qualifié d'ensemble de réponse du programme non positif
$\Pi$ si et seulement si il s'agit d'un ensemble de réponse pour le programme positif $\Pi^S$.
Nous notons que plusieurs ensembles de réponse peuvent être solutions du même programme
non défini.
Dans la pratique, un \textit{solver} tel que \tool{Clingo} peut être configuré pour
les énumérer tous ou pour n'en trouver qu'un.

\begin{example}
  Considérons le programme ASP suivant :
 \begin{align*}
   a &\la \nota b.\\
   b &\la \nota a.
 \end{align*}
 Ce programme n'est pas positif, et il contient les deux ensembles de réponse suivants :
 $\{a\}$ et $\{b\}$.
\end{example}

Il est à noter qu'il est possible de définir une règle ne comportant pas de corps
(c'est-à-dire comportant zéro atomes et négations d'atomes).
Une telle règle est aussi appelée un \emph{fait},
et son atome de tête appartient par conséquence à tous les ensembles de réponse
du programme.
ainsi, les données représentant le modèle à étudier
(à savoir le modèle de Frappes de Processus canoniques original,
mais aussi le graphe des interactions et les paramètres inférés)
sont exprimés en ASP à l'aide de faits.

\begin{example}
\exlabel{impl-component}
  Afin de définir les trois composants contenus dans la \figref{infer-ex-ph-nocoop},
  nous utilisons le programme suivant :
  \begin{align*}
    &\component(a, 2). \\
    &\component(b, 1). \\
    &\component(c, 1).
  \end{align*}
  Ce programme ne contient que des faits utilisant le prédicat $\components$
  précédemment mentionné \vexpageref{impl-asp-atom}.
  Par ailleurs, les symboles $a$, $b$, $c$, $1$ et $2$ représentent des constantes.
  Ce programme produit un seul ensemble de réponse,
  qui contient simplement les trois atomes qui y sont mentionnés.
\end{example}



\subsubsection{Variables}
\seclabel{imple-variables}

L'utilisation de variables, déjà évoquée précédemment, permet de généraliser des règles.
Par exemple, pour décrire les ensembles de tous les niveaux d'expression de chaque composant
(c'est-à-dire l'ensemble $\segm{0}{l_a}$ pour tout $a \in \component$),
il est envisageable d'utiliser un atome de la forme : $\componentlevels(a, k)$
pour stipuler que : $k \in \segm{0}{l_a}$.
Les variables viennent alors en aide pour énumérer toutes les constantes entières $k$
correspondant à un niveau d'expression possible :
avant la résolution, une étape de \textit{ground} permet de remplacer, dans chaque règle,
toutes les variables par toutes les constantes possibles ;
en d'autres termes, ce processus permet d'obtenir un programme équivalent sans variable.
La règle suivante, par exemple, contient trois variables ($\var{A}$, $\var{K}$ et $\var{M}$)
et permet d'énumérer l'ensemble des niveaux d'expression possibles de chaque composant
dans le modèle :
\begin{align*}
  \componentlevels(A, K) \la \component(\var{A}, \var{M}), 0 \leq K \leq M.
\end{align*}
où la notation $\leq$ possède la même signification que l'opérateur mathématique.

\begin{example}
  Afin de représenter tous les niveaux d'expression des composants du modèle de la
  \figref{infer-ex-ph-nocoop},
  nous utilisons le programme suivant, qui reprend les faits du programme proposé
  \vexpageref{asp-component} :
  \begin{align*}
    &\component(a, 2). \\
    &\component(b, 1). \\
    &\component(c, 1). \\
    &\componentlevels(A, K) \la \component(\var{A}, \var{M}), 0 \leq K \leq M.
  \end{align*}
  L'ensemble de réponse suivant est alors obtenu :
  \begin{align*}
    &\{&&\component(a, 2),
    &&\component(b, 1), \\
    &&&\component(c, 1),
    &&\componentlevels(a, 0), \\
    &&&\componentlevels(a, 1),
    &&\componentlevels(a, 2), \\
    &&&\componentlevels(b, 0),
    &&\componentlevels(b, 1), \\
    &&&\componentlevels(c, 0),
    &&\componentlevels(c, 1). &\}
  \end{align*}
\end{example}



\subsection{Règles de cardinalité}
\seclabel{impl-cardinality-rules}

En tant qu'extension des règles simples, les \emph{règles de cardinalité} s'avèrent
utiles pour énumérer des ensembles de réponse.
La tête d'une règle de cardinalité spécifie un ensemble d'atomes $H$ et deux entiers
$min$ et $max$, et on note une telle règle :
\begin{align*}
  min\ \{\ H\ \}\ max \la \atom{A}_1, \atom{A}_2, \dots, \atom{A}_n, \nota \atom{B}_1,
  \nota \atom{B}_2, \dots, \nota \atom{B}_m.
\end{align*}
Pour chaque règle de ce type, autant d'ensembles de réponse sont créés, de façon à ce que
chaque ensemble de réponse $S$ vérifie :
\begin{align*}
  min \leq |S \cap H| \leq max
\end{align*}
et chaque atome $\atom{H}_i \in S \cap H$ respecte la règle simple suivante :
\begin{align*}
  \atom{H}_i \la \atom{A}_1, \atom{A}_2, \dots, \atom{A}_n, \nota \atom{B}_1,
  \nota \atom{B}_2, \dots, \nota \atom{B}_m.
\end{align*}
en d'autres termes, tous les ensembles de réponses générés contiennent un sous-ensemble de
l'ensemble $H$ dont la cardinalité est comprise entre $min$ et $max$,
et pour lesquels la condition dans le corps de la cardinalité est vérifiée.
L'ensemble des atomes $H = \{ \atom{H}_1, \atom{H}_2, \dots, \atom{H}_p \}$
est souvent décrit de la façon suivante : $H = \{ \atom{P} \mid \atom{Q} \}$,
qui est un raccourci pour qualifier l'ensemble des atomes de la forme
$\atom{P}$ et pour lesquels $\atom{Q}$ est vérifié.

% Cardinality rules turn out to be convenient to enumerate all possible parametrizations by creating multiple answer sets.
% For functional purposes, a unique label is assigned to every possible set of resources of a given component.
% Thus, we denote $\omega_p$ the set of resources of a given component $a$ labeled by $p$,
% and naturally, $K_{a,\omega_p}$ is the related parameter.
% %and in the following we note $K_{a,\omega_p}$ the parameter of component $a$ whose set of resources $\omega$ is assigned to the label $p$.
% We note that labeling the sets of resources of a component is obviously equivalent to labeling its parameters.
% Then, suppose that:
% \begin{itemize}
%   \item $\paramlabel(a, p)$ states that $p$ is a valid label for a set of resources of component $a$ (and therefore $K_{a,\omega_p}$ is a valid parameter);
%   \item $\param(a, p, i)$ states that: $i \in K_{a, \omega_p}$;
%   \item $\inferedparam(a, p)$ states that the parameter inference of $K_{a, \omega_p}$ was conclusive (\pref{pps:param-K}).
% \end{itemize}
% It is thereby possible to enumerate the possible values of all parameters for which \pref{pps:param-K} was not conclusive, with the following cardinality rule:
% \begin{align*}
%   & 1\ \{\ \param(\var{A}, \var{P}, \var{I}) \mid \componentlevels(\var{A}, \var{I})\ \}\ \infty\ \la \\
%   & \qquad\qquad\qquad \paramlabel(\var{A}, \var{P}), \nota \inferedparam(\var{A}, \var{P}).
% \end{align*}
% Indeed, this rule applies to any possible parameter $\var{P}$ of any component $\var{A}$ ($\paramlabel$) whose value is still unknown ($\nota \inferedparam$),
% and states that any expression level $\var{I}$ of this component ($\componentlevels$) can belong to the value of the parameter ($\param$).
% Furthermore, the lower bound is $1$, which forces each enumerated parameter to contain at least one value,
% but no upper bound is specified ($\infty$) for the size of each parameter
% (which is in fact already bounded by the number of possible expression levels of the related component).
% %each parameter contains at least $1$ value, as stated by the lower bound, and has no upper bound ($\infty$) but the number of expression levels of its component.
% In other worlds, this cardinality rule creates as many answer sets as there are \emph{candidate} parametrizations
% so that if $K_{a, \omega_p}$ could not be inferred by \pref{pps:param-K}, then
% $K_{a, \omega_p} \subset \segm{0}{l_a} \wedge K_{a, \omega_p} \neq \emptyset$
% (thus completely disregarding the notion of admissible parametrizations given in \pref{ssec:admissible-K} or the fact that parameters have to be intervals).
% 
% 
% 
% \begin{example}\label{ex:cardinality}
% In the scope of \pref{ex:infer-param-runningPH-1}, $K_{a,\{a,b\}}$ and $K_{a,\{a,c\}}$ could not be inferred by \pref{pps:param-K}.
% The previous cardinality rule allows to produce 49 parametrizations, in which these two parameters can take all possible values:
% %The enumeration thus produces 36 parametrizations, in which these parameters can take all possible values:
% %(as, in this case, the assumptions of \pref{ssec:admissible-K} bring no new constraint):
% \begin{align*}
%   (K_{a,\{a,b\}} ; K_{a,\{a,c\}}) \in \{ \segm{0}{0} , \segm{1}{1} , \segm{2}{2} , \segm{0}{1} , \segm{1}{2} , \segm{0}{2}, \{ 0, 2 \} \}^2
% \end{align*}
% and all the other parameters keep their inferred values.
% %These parametrizations take the form of sets of $\param$ atoms.
% Note that $\{ 0, 2 \}$ belongs to the set of candidate parametrizations
% as no rule specifying that a parameter has to be an interval has been defined yet.
% \end{example}
% 
% 
% 
% \subsection{Constraints}\label{sssec:constraints}
% Finally, a \emph{constraint} is a rule with no $head$ part:
% \begin{align*}
%   \la \atom{A}_1, \atom{A}_2, \dots, \atom{A}_n, \nota \atom{B}_1, \nota \atom{B}_2, \dots, \nota \atom{B}_m.
% \end{align*}
% A constraint is satisfied only if its $body$ is not satisfied,
% which thus allows to invalidate answer sets containing some unwanted combinations of atoms.
% In the scope of parameters enumeration, for example, constraints are especially useful to filter parametrizations
% that contain non-interval parameters, or that do not respect the assumptions of \pref{ssec:admissible-K}.
% Indeed, suppose that:
% \begin{itemize}
%   \item $\lessactive(a, p, q)$ states that $\omega_p$ is a set of resources of $a$ with (loosely) less activators and more inhibitors than $\omega_q$;
%   \item $\paraminf(a, p, q)$ states that: $K_{a,\omega_p} \leqsegm K_{a,\omega_q}$.
% \end{itemize}
% Then, the monotonicity assumption (\pref{pro:param-enum-monotonicity}) is formulated as the following constraint:
% \begin{align*}
%   \la \lessactive(\var{A}, \var{P}, \var{Q}), \nota \paraminf(\var{A}, \var{P}, \var{Q}).
% \end{align*}
% Indeed, this constraint removes all parametrization results where parameters $K_{\var{A},\omega_\var{P}}$ and $K_{\var{A},\omega_\var{Q}}$ exist
% such that $\var{A}$ is less activated by the set of resources $\omega_\var{P}$ than it is by $\omega_\var{Q}$,
% but $K_{\var{A},\omega_\var{Q}} \ltsegm K_{\var{A},\omega_\var{P}}$,
% thus violating the monotonicity assumption.
% Of course, other assumptions can be formulated in the same way.
% 
% \begin{example}
% The set of candidate values given in \pref{ex:cardinality} can be filtered using constraints.
% For example, a constraint was written in order to obtain only interval parameters
% (thus avoiding parameters with “gaps” such as $\{ 0, 2 \}$).
% Applying such a constraint would reduce the set of possible values for the parameters $K_{a,\{a,b\}}$ and $K_{a,\{a,c\}}$ to:
% \begin{align*}
%   (K_{a,\{a,b\}} ; K_{a,\{a,c\}}) \in \{ \segm{0}{0} , \segm{1}{1} , \segm{2}{2} , \segm{0}{1} , \segm{1}{2} , \segm{0}{2} \}^2
% \end{align*}
% 
% Then, due to the fact that the parameters $K_{a,\{b\}} = \segm{1}{1}$ and $K_{a,\{c\}} = \segm{1}{1}$ could be inferred,
% the monotonicity assumption (\pref{pro:param-enum-monotonicity} and expressed in ASP above) removes all parametrizations with:
% $0 \in K_{a,\{a,b\}} \vee 0 \in K_{a,\{a,c\}}$.
% In the end, the remaining possible values for the two parameters that were not inferred are:
% \begin{align*}
%   (K_{a,\{a,b\}} ; K_{a,\{a,c\}}) \in \{ \segm{1}{1} , \segm{2}{2} , \segm{1}{2} \}^2
% \end{align*}
% All these candidates respect the other properties of \pref{ssec:admissible-K} and no more candidates are filtered.
% We thus obtain the results of \pref{ex:enum-param-runningPH-1}.
% \end{example}
% 
% 
% 
% \medskip
% 
% This subsection succinctly described how ASP programs come in handy to represent a model and solve complex problems on it.
% %all steps of Thomas' modeling inference.
% It finds a particularly interesting application in the enumeration of parameters:
% all possible parametrizations are generated in separate answer sets,
% and integrity constraints are formulated to remove those that do not fit the assumptions of admissible parametrizations,
% thus reducing the number of candidate parametrizations to be considered in the end.
% However, all steps of the inference presented in this paper (\pref{sec:infer-IG} \& \ref{sec:infer-K})
% were implemented in and benefited from this programming paradigm.
% %, although in significantly different ways.